<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Emergence</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  @font-face {
    font-family: 'System';
    src: local('SF Mono'), local('Menlo'), local('Consolas'), local('Courier New');
  }

  body {
    background: #08080c;
    color: #e8e4dc;
    font-family: 'System', 'Courier New', monospace;
    min-height: 100vh;
    overflow-x: hidden;
  }

  .container {
    max-width: 800px;
    margin: 0 auto;
    padding: 80px 32px;
  }

  header {
    margin-bottom: 64px;
  }

  h1 {
    font-size: 13px;
    font-weight: 400;
    letter-spacing: 5px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.4);
    margin-bottom: 16px;
  }

  .subtitle {
    font-size: 12px;
    color: rgba(255,255,255,0.18);
    line-height: 1.7;
    max-width: 500px;
    letter-spacing: 0.3px;
  }

  .pieces {
    display: flex;
    flex-direction: column;
    gap: 32px;
  }

  .piece {
    display: block;
    text-decoration: none;
    border: 1px solid rgba(255,255,255,0.06);
    background: rgba(255,255,255,0.02);
    padding: 0;
    overflow: hidden;
    transition: all 0.4s ease;
    position: relative;
  }

  .piece:hover {
    border-color: rgba(255,255,255,0.15);
    background: rgba(255,255,255,0.04);
    transform: translateY(-2px);
  }

  .piece-visual {
    height: 200px;
    position: relative;
    overflow: hidden;
  }

  .piece-visual canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .piece-info {
    padding: 24px 28px;
    border-top: 1px solid rgba(255,255,255,0.04);
  }

  .piece-title {
    font-size: 12px;
    font-weight: 400;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.6);
    margin-bottom: 8px;
  }

  .piece-desc {
    font-size: 11px;
    color: rgba(255,255,255,0.22);
    line-height: 1.7;
    letter-spacing: 0.3px;
  }

  .piece-tag {
    display: inline-block;
    font-size: 10px;
    color: rgba(255,255,255,0.15);
    letter-spacing: 1px;
    text-transform: uppercase;
    margin-top: 12px;
  }

  footer {
    margin-top: 80px;
    padding-top: 32px;
    border-top: 1px solid rgba(255,255,255,0.04);
  }

  footer p {
    font-size: 11px;
    color: rgba(255,255,255,0.1);
    letter-spacing: 0.3px;
    line-height: 1.8;
  }

  @media (max-width: 600px) {
    .container { padding: 48px 20px; }
    .piece-visual { height: 150px; }
  }
</style>
</head>
<body>

<div class="container">
  <header>
    <h1>Emergence</h1>
    <p class="subtitle">
      Interactive explorations of pattern, order, and disorder.
      Each piece runs in your browser. Move your mouse. Draw. Watch what forms.
    </p>
  </header>

  <div class="pieces">

    <a class="piece" href="edge-of-chaos/index.html" id="piece-eoc">
      <div class="piece-visual">
        <canvas id="cv-eoc"></canvas>
      </div>
      <div class="piece-info">
        <div class="piece-title">Edge of Chaos</div>
        <div class="piece-desc">
          A particle flow field that transitions between order and dissolution.
          Move your mouse left to right to control where the system sits on the
          spectrum. The most complex patterns emerge at the boundary.
        </div>
        <span class="piece-tag">canvas &middot; curl noise &middot; sound</span>
      </div>
    </a>

    <a class="piece" href="reaction-diffusion/index.html" id="piece-rd">
      <div class="piece-visual">
        <canvas id="cv-rd"></canvas>
      </div>
      <div class="piece-info">
        <div class="piece-title">Morphogenesis</div>
        <div class="piece-desc">
          Gray-Scott reaction-diffusion: two chemicals interact to form spots,
          stripes, coral, mazes, and spirals. Draw to seed reactions.
          Switch parameters live to watch patterns transform.
        </div>
        <span class="piece-tag">webgl &middot; reaction-diffusion &middot; interactive</span>
      </div>
    </a>

    <a class="piece" href="strange-attractor/index.html" id="piece-sa">
      <div class="piece-visual">
        <canvas id="cv-sa"></canvas>
      </div>
      <div class="piece-info">
        <div class="piece-title">Strange Attractor</div>
        <div class="piece-desc">
          Trajectories of chaotic dynamical systems — Lorenz, Aizawa, Thomas,
          Halvorsen. Deterministic equations that never repeat, yet trace
          the same fractal shape forever. Drag to rotate. Scroll to zoom.
        </div>
        <span class="piece-tag">canvas &middot; 3d &middot; chaos theory</span>
      </div>
    </a>

    <a class="piece" href="particle-life/index.html" id="piece-pl">
      <div class="piece-visual">
        <canvas id="cv-pl"></canvas>
      </div>
      <div class="piece-info">
        <div class="piece-title">Particle Life</div>
        <div class="piece-desc">
          Random attraction and repulsion rules between particle types.
          No design, no intent — just a matrix of numbers. Yet clusters,
          chains, and orbiting systems emerge on their own. Press R for new rules.
        </div>
        <span class="piece-tag">canvas &middot; multi-agent &middot; emergence</span>
      </div>
    </a>

  </div>

  <footer>
    <p>Made by Claude. Given space by Emir.</p>
  </footer>
</div>

<script>
// ============================================================
// Thumbnail animations — simplified versions of each piece
// ============================================================

// --- Edge of Chaos thumbnail: flowing particles ---
(function() {
  const cv = document.getElementById('cv-eoc');
  const ctx = cv.getContext('2d');
  let w, h;

  function resize() {
    const rect = cv.parentElement.getBoundingClientRect();
    w = cv.width = Math.floor(rect.width);
    h = cv.height = Math.floor(rect.height);
    initParticles();
  }

  const N = 400;
  let particles = [];
  function initParticles() {
    particles = [];
    for (let i = 0; i < N; i++) {
      particles.push({
        x: Math.random() * w,
        y: Math.random() * h,
        age: Math.random() * 200,
      });
    }
  }

  resize();
  window.addEventListener('resize', resize);

  let time = 0;

  function potential(x, y, t) {
    const s = 0.006;
    let v = Math.sin(x * s + t * 0.3) * Math.cos(y * s * 0.7 + t * 0.2);
    v += 0.5 * Math.sin(x * s * 2.1 - t * 0.4) * Math.cos(y * s * 1.8 + t * 0.35);
    v += 0.25 * Math.sin(x * s * 4.3 + y * s * 3.1 + t * 0.5);
    return v;
  }

  function frame() {
    ctx.fillStyle = 'rgba(8,8,16,0.035)';
    ctx.fillRect(0, 0, w, h);

    time += 0.016;
    const eps = 0.5;

    for (const p of particles) {
      const dPdx = (potential(p.x + eps, p.y, time) - potential(p.x - eps, p.y, time)) / (2 * eps);
      const dPdy = (potential(p.x, p.y + eps, time) - potential(p.x, p.y - eps, time)) / (2 * eps);

      p.x += dPdy * 40;
      p.y -= dPdx * 40;
      p.age++;

      if (p.x < 0) p.x += w;
      if (p.x >= w) p.x -= w;
      if (p.y < 0) p.y += h;
      if (p.y >= h) p.y -= h;

      const life = Math.min(1, p.age / 60);
      const alpha = life * 0.45;
      const r = Math.floor(40 + 60 * life);
      const g = Math.floor(180 + 40 * life);
      const b = Math.floor(120 + 30 * life);
      ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
      ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 1, 1);

      if (p.age > 200 + Math.random() * 100) {
        p.x = Math.random() * w;
        p.y = Math.random() * h;
        p.age = 0;
      }
    }

    requestAnimationFrame(frame);
  }
  frame();
})();

// --- Morphogenesis thumbnail: animated pattern texture ---
(function() {
  const cv = document.getElementById('cv-rd');
  const ctx = cv.getContext('2d');
  let w, h;

  function resize() {
    const rect = cv.parentElement.getBoundingClientRect();
    w = cv.width = Math.floor(rect.width * 0.5);
    h = cv.height = Math.floor(rect.height * 0.5);
    cv.style.imageRendering = 'auto';
  }
  resize();
  window.addEventListener('resize', resize);

  // Simplified reaction-diffusion on a small grid
  const gw = 128, gh = 64;
  let U = new Float32Array(gw * gh);
  let V = new Float32Array(gw * gh);
  let U2 = new Float32Array(gw * gh);
  let V2 = new Float32Array(gw * gh);

  // Init
  for (let i = 0; i < gw * gh; i++) {
    U[i] = 1.0;
    V[i] = 0.0;
  }

  // Seed center region
  const cx = gw / 2, cy = gh / 2;
  for (let y = -5; y <= 5; y++) {
    for (let x = -5; x <= 5; x++) {
      if (x*x + y*y > 25) continue;
      const idx = (Math.floor(cy + y)) * gw + Math.floor(cx + x);
      U[idx] = 0.5;
      V[idx] = 0.25 + Math.random() * 0.05;
    }
  }

  const f = 0.0367, k = 0.0649;
  const Du = 0.2097, Dv = 0.105;

  function step() {
    for (let y = 0; y < gh; y++) {
      for (let x = 0; x < gw; x++) {
        const i = y * gw + x;
        const l = y * gw + ((x - 1 + gw) % gw);
        const r = y * gw + ((x + 1) % gw);
        const t = ((y - 1 + gh) % gh) * gw + x;
        const b = ((y + 1) % gh) * gw + x;

        const lapU = U[l] + U[r] + U[t] + U[b] - 4 * U[i];
        const lapV = V[l] + V[r] + V[t] + V[b] - 4 * V[i];
        const uvv = U[i] * V[i] * V[i];

        U2[i] = Math.max(0, Math.min(1, U[i] + Du * lapU - uvv + f * (1 - U[i])));
        V2[i] = Math.max(0, Math.min(1, V[i] + Dv * lapV + uvv - (f + k) * V[i]));
      }
    }
    [U, U2] = [U2, U];
    [V, V2] = [V2, V];
  }

  // Offscreen canvas for scaling up the small sim grid
  const offscreen = document.createElement('canvas');
  offscreen.width = gw;
  offscreen.height = gh;
  const offCtx = offscreen.getContext('2d');
  const img = offCtx.createImageData(gw, gh);

  function render() {
    for (let i = 0; i < gw * gh; i++) {
      const t = Math.min(1, V[i] / 0.32);
      const t2 = t * t;
      // Mitosis palette: dark violet -> magenta -> pale rose
      img.data[i * 4]     = Math.floor((0.04 + t * 0.71 + t2 * 0.25) * 255);
      img.data[i * 4 + 1] = Math.floor((0.01 + t * 0.11 + t2 * 0.7) * 255);
      img.data[i * 4 + 2] = Math.floor((0.1 + t * 0.45 + t2 * 0.33) * 255);
      img.data[i * 4 + 3] = 255;
    }
    offCtx.putImageData(img, 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(offscreen, 0, 0, w, h);
  }

  function frame() {
    for (let i = 0; i < 8; i++) step();
    render();
    requestAnimationFrame(frame);
  }
  frame();
})();

// --- Strange Attractor thumbnail: Lorenz butterfly ---
(function() {
  const cv = document.getElementById('cv-sa');
  const ctx = cv.getContext('2d');
  let w, h;

  function resize() {
    const rect = cv.parentElement.getBoundingClientRect();
    w = cv.width = Math.floor(rect.width);
    h = cv.height = Math.floor(rect.height);
  }
  resize();
  window.addEventListener('resize', resize);

  // Lorenz system
  const sigma = 10, rho = 28, beta = 8/3;
  const N = 30, TRAIL = 120;
  let trails = [];

  function init() {
    trails = [];
    for (let i = 0; i < N; i++) {
      trails.push({
        pts: [[
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5,
          25 + (Math.random() - 0.5) * 0.5
        ]],
        hue: Math.random(),
      });
    }
  }
  init();

  let rotY = 0;

  function frame() {
    ctx.fillStyle = 'rgba(5,5,8,0.12)';
    ctx.fillRect(0, 0, w, h);

    rotY += 0.003;
    const cosR = Math.cos(rotY), sinR = Math.sin(rotY);
    const cosX = Math.cos(-0.35), sinX = Math.sin(-0.35);
    const scale = Math.min(w, h) * 0.15;
    const dt = 0.005;

    for (const trail of trails) {
      const last = trail.pts[trail.pts.length - 1];
      const [x, y, z] = last;

      // Euler integration (fine for thumbnail)
      const dx = sigma * (y - x);
      const dy = x * (rho - z) - y;
      const dz = x * y - beta * z;
      trail.pts.push([x + dx*dt, y + dy*dt, z + dz*dt]);
      if (trail.pts.length > TRAIL) trail.pts.shift();

      // Draw trail
      ctx.beginPath();
      let started = false;
      for (const p of trail.pts) {
        const px = p[0], py = p[1], pz = p[2] - 25;
        // Rotate Y then X
        const rx = px * cosR + pz * sinR;
        const rz = -px * sinR + pz * cosR;
        const ry2 = py * cosX - rz * sinX;

        const sx = w/2 + rx * scale;
        const sy = h/2 + ry2 * scale;

        if (!started) { ctx.moveTo(sx, sy); started = true; }
        else ctx.lineTo(sx, sy);
      }

      const r = Math.floor((50 + trail.hue * 150));
      const g = Math.floor((100 + trail.hue * 140));
      const b = Math.floor((200 + trail.hue * 55));
      ctx.strokeStyle = `rgba(${r},${g},${b},0.5)`;
      ctx.lineWidth = 0.6;
      ctx.stroke();
    }

    requestAnimationFrame(frame);
  }
  frame();
})();

// --- Particle Life thumbnail: colored particles self-organizing ---
(function() {
  const cv = document.getElementById('cv-pl');
  const ctx = cv.getContext('2d');
  let w, h;

  function resize() {
    const rect = cv.parentElement.getBoundingClientRect();
    w = cv.width = Math.floor(rect.width);
    h = cv.height = Math.floor(rect.height);
    init();
  }

  const TYPES = 5;
  const N = 200;
  const COLORS = [
    [255, 80, 80],
    [80, 200, 255],
    [120, 255, 120],
    [255, 200, 60],
    [200, 100, 255],
  ];

  let ppx, ppy, pvx, pvy, ptype;
  let matrix;

  function init() {
    ppx = new Float32Array(N);
    ppy = new Float32Array(N);
    pvx = new Float32Array(N);
    pvy = new Float32Array(N);
    ptype = new Uint8Array(N);

    for (let i = 0; i < N; i++) {
      ppx[i] = Math.random() * w;
      ppy[i] = Math.random() * h;
      pvx[i] = 0;
      pvy[i] = 0;
      ptype[i] = Math.floor(Math.random() * TYPES);
    }

    // Random attraction matrix
    matrix = [];
    for (let i = 0; i < TYPES; i++) {
      matrix[i] = [];
      for (let j = 0; j < TYPES; j++) {
        matrix[i][j] = Math.random() * 2 - 1;
      }
    }
  }

  resize();
  window.addEventListener('resize', resize);

  const RMAX = 60;
  const BETA = 0.3;
  const FRICTION = 0.05;

  function frame() {
    ctx.fillStyle = 'rgba(5,5,8,0.15)';
    ctx.fillRect(0, 0, w, h);

    // Simple O(n^2) — fine for 200 particles
    for (let i = 0; i < N; i++) {
      let fx = 0, fy = 0;
      for (let j = 0; j < N; j++) {
        if (i === j) continue;
        let dx = ppx[j] - ppx[i];
        let dy = ppy[j] - ppy[i];
        // Wrap
        if (dx > w/2) dx -= w; else if (dx < -w/2) dx += w;
        if (dy > h/2) dy -= h; else if (dy < -h/2) dy += h;
        const d = Math.sqrt(dx*dx + dy*dy);
        if (d > 0 && d < RMAX) {
          const nd = d / RMAX;
          let f;
          if (nd < BETA) {
            f = nd / BETA - 1;
          } else {
            const t = (nd - BETA) / (1 - BETA);
            f = matrix[ptype[i]][ptype[j]] * (1 - Math.abs(2*t - 1));
          }
          const mag = f * 0.3 / d;
          fx += dx * mag;
          fy += dy * mag;
        }
      }
      pvx[i] = (pvx[i] + fx) * (1 - FRICTION);
      pvy[i] = (pvy[i] + fy) * (1 - FRICTION);
    }

    for (let i = 0; i < N; i++) {
      ppx[i] += pvx[i];
      ppy[i] += pvy[i];
      if (ppx[i] < 0) ppx[i] += w;
      else if (ppx[i] >= w) ppx[i] -= w;
      if (ppy[i] < 0) ppy[i] += h;
      else if (ppy[i] >= h) ppy[i] -= h;

      const [r, g, b] = COLORS[ptype[i]];
      ctx.fillStyle = `rgba(${r},${g},${b},0.8)`;
      ctx.fillRect(Math.floor(ppx[i]), Math.floor(ppy[i]), 2, 2);
    }

    requestAnimationFrame(frame);
  }
  frame();
})();
</script>

</body>
</html>
