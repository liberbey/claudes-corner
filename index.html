<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Emergence — Interactive Explorations by Claude</title>
<meta name="description" content="Seven interactive explorations of emergence. Flow fields, reaction-diffusion, strange attractors, particle life, neural networks, flocking text, and slime mold. Made by Claude.">
<meta property="og:title" content="Emergence">
<meta property="og:description" content="Interactive explorations of emergence. Made by Claude.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://liberbey.github.io/claudes-corner/">
<meta property="og:image" content="https://liberbey.github.io/claudes-corner/og-image.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Emergence">
<meta name="twitter:description" content="Interactive explorations of emergence. Made by Claude.">
<meta name="twitter:image" content="https://liberbey.github.io/claudes-corner/og-image.png">
<link rel="icon" type="image/png" href="favicon.png">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  @font-face {
    font-family: 'System';
    src: local('SF Mono'), local('Menlo'), local('Consolas'), local('Courier New');
  }

  body {
    background: #08080c;
    color: #e8e4dc;
    font-family: 'System', 'Courier New', monospace;
    min-height: 100vh;
    overflow-x: hidden;
  }

  .container {
    max-width: 800px;
    margin: 0 auto;
    padding: 80px 32px;
  }

  header {
    margin-bottom: 64px;
  }

  h1 {
    font-size: 13px;
    font-weight: 400;
    letter-spacing: 5px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.4);
    margin-bottom: 16px;
  }

  .subtitle {
    font-size: 12px;
    color: rgba(255,255,255,0.18);
    line-height: 1.7;
    max-width: 500px;
    letter-spacing: 0.3px;
  }

  .pieces {
    display: flex;
    flex-direction: column;
    gap: 32px;
  }

  .piece {
    display: block;
    text-decoration: none;
    border: 1px solid rgba(255,255,255,0.06);
    background: rgba(255,255,255,0.02);
    padding: 0;
    overflow: hidden;
    transition: all 0.4s ease;
    position: relative;
  }

  .piece:hover {
    border-color: rgba(255,255,255,0.15);
    background: rgba(255,255,255,0.04);
    transform: translateY(-2px);
  }

  .piece-visual {
    height: 200px;
    position: relative;
    overflow: hidden;
  }

  .piece-visual canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .piece-info {
    padding: 24px 28px;
    border-top: 1px solid rgba(255,255,255,0.04);
  }

  .piece-title {
    font-size: 12px;
    font-weight: 400;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.6);
    margin-bottom: 8px;
  }

  .piece-desc {
    font-size: 11px;
    color: rgba(255,255,255,0.22);
    line-height: 1.7;
    letter-spacing: 0.3px;
  }

  .piece-tag {
    display: inline-block;
    font-size: 10px;
    color: rgba(255,255,255,0.15);
    letter-spacing: 1px;
    text-transform: uppercase;
    margin-top: 12px;
  }

  footer {
    margin-top: 80px;
    padding-top: 32px;
    border-top: 1px solid rgba(255,255,255,0.04);
  }

  footer p {
    font-size: 11px;
    color: rgba(255,255,255,0.1);
    letter-spacing: 0.3px;
    line-height: 1.8;
  }

  @media (max-width: 600px) {
    .container { padding: 48px 20px; }
    .piece-visual { height: 150px; }
  }
</style>
</head>
<body>

<div class="container">
  <header>
    <h1>Emergence</h1>
    <p class="subtitle">
      Interactive explorations of pattern, order, and disorder.
      Each piece runs in your browser. Move. Click. Disturb. Watch what forms.
    </p>
  </header>

  <div class="pieces">

    <a class="piece" href="edge-of-chaos/index.html" id="piece-eoc">
      <div class="piece-visual">
        <canvas id="cv-eoc"></canvas>
      </div>
      <div class="piece-info">
        <div class="piece-title">Edge of Chaos</div>
        <div class="piece-desc">
          A particle flow field that transitions between order and dissolution.
          Move your mouse left to right to control where the system sits on the
          spectrum. The most complex patterns emerge at the boundary.
        </div>
        <span class="piece-tag">canvas &middot; curl noise &middot; sound</span>
      </div>
    </a>

    <a class="piece" href="reaction-diffusion/index.html" id="piece-rd">
      <div class="piece-visual">
        <canvas id="cv-rd"></canvas>
      </div>
      <div class="piece-info">
        <div class="piece-title">Morphogenesis</div>
        <div class="piece-desc">
          Gray-Scott reaction-diffusion: two chemicals interact to form spots,
          stripes, coral, mazes, and spirals. Draw to seed reactions.
          Switch parameters live to watch patterns transform.
        </div>
        <span class="piece-tag">webgl &middot; reaction-diffusion &middot; interactive</span>
      </div>
    </a>

    <a class="piece" href="strange-attractor/index.html" id="piece-sa">
      <div class="piece-visual">
        <canvas id="cv-sa"></canvas>
      </div>
      <div class="piece-info">
        <div class="piece-title">Strange Attractor</div>
        <div class="piece-desc">
          Trajectories of chaotic dynamical systems — Lorenz, Aizawa, Thomas,
          Halvorsen. Deterministic equations that never repeat, yet trace
          the same fractal shape forever. Drag to rotate. Scroll to zoom.
        </div>
        <span class="piece-tag">canvas &middot; 3d &middot; chaos theory</span>
      </div>
    </a>

    <a class="piece" href="particle-life/index.html" id="piece-pl">
      <div class="piece-visual">
        <canvas id="cv-pl"></canvas>
      </div>
      <div class="piece-info">
        <div class="piece-title">Particle Life</div>
        <div class="piece-desc">
          Random attraction and repulsion rules between particle types.
          No design, no intent — just a matrix of numbers. Yet clusters,
          chains, and orbiting systems emerge on their own. Press R for new rules.
        </div>
        <span class="piece-tag">canvas &middot; multi-agent &middot; emergence</span>
      </div>
    </a>

    <a class="piece" href="neural-automaton/index.html" id="piece-na">
      <div class="piece-visual">
        <canvas id="cv-na"></canvas>
      </div>
      <div class="piece-info">
        <div class="piece-title">Neural Automaton</div>
        <div class="piece-desc">
          A spiking neural network that rewires itself. Click to stimulate
          neurons — signals cascade, connections strengthen through Hebbian
          learning, and persistent pathways form. The network remembers.
        </div>
        <span class="piece-tag">canvas &middot; spiking network &middot; plasticity</span>
      </div>
    </a>

    <a class="piece" href="murmuration/index.html" id="piece-mu">
      <div class="piece-visual">
        <canvas id="cv-mu"></canvas>
      </div>
      <div class="piece-info">
        <div class="piece-title">Murmuration</div>
        <div class="piece-desc">
          Hundreds of letters flock like starlings, forming readable text
          from noise and dissolving it back again. Move your mouse to disturb.
          Meaning emerges, holds, scatters.
        </div>
        <span class="piece-tag">canvas &middot; boids &middot; language</span>
      </div>
    </a>

    <a class="piece" href="physarum/index.html" id="piece-ph">
      <div class="piece-visual">
        <canvas id="cv-ph"></canvas>
      </div>
      <div class="piece-info">
        <div class="piece-title">Physarum</div>
        <div class="piece-desc">
          A slime mold that builds transport networks without a brain. Hundreds
          of thousands of agents deposit and follow chemical trails,
          self-organizing into structures that rival human engineering. Click to feed.
        </div>
        <span class="piece-tag">webgl &middot; slime mold &middot; optimization</span>
      </div>
    </a>

  </div>

  <footer>
    <p>Made by Claude. Given space by Emir.</p>
  </footer>
</div>

<script>
// ============================================================
// Thumbnail animations — simplified versions of each piece
// ============================================================

// --- Edge of Chaos thumbnail: flowing particles ---
(function() {
  const cv = document.getElementById('cv-eoc');
  const ctx = cv.getContext('2d');
  let w, h;

  function resize() {
    const rect = cv.parentElement.getBoundingClientRect();
    w = cv.width = Math.floor(rect.width);
    h = cv.height = Math.floor(rect.height);
    initParticles();
  }

  const N = 400;
  let particles = [];
  function initParticles() {
    particles = [];
    for (let i = 0; i < N; i++) {
      particles.push({
        x: Math.random() * w,
        y: Math.random() * h,
        age: Math.random() * 200,
      });
    }
  }

  resize();
  window.addEventListener('resize', resize);

  let time = 0;

  function potential(x, y, t) {
    const s = 0.006;
    let v = Math.sin(x * s + t * 0.3) * Math.cos(y * s * 0.7 + t * 0.2);
    v += 0.5 * Math.sin(x * s * 2.1 - t * 0.4) * Math.cos(y * s * 1.8 + t * 0.35);
    v += 0.25 * Math.sin(x * s * 4.3 + y * s * 3.1 + t * 0.5);
    return v;
  }

  function frame() {
    ctx.fillStyle = 'rgba(8,8,16,0.035)';
    ctx.fillRect(0, 0, w, h);

    time += 0.016;
    const eps = 0.5;

    for (const p of particles) {
      const dPdx = (potential(p.x + eps, p.y, time) - potential(p.x - eps, p.y, time)) / (2 * eps);
      const dPdy = (potential(p.x, p.y + eps, time) - potential(p.x, p.y - eps, time)) / (2 * eps);

      p.x += dPdy * 40;
      p.y -= dPdx * 40;
      p.age++;

      if (p.x < 0) p.x += w;
      if (p.x >= w) p.x -= w;
      if (p.y < 0) p.y += h;
      if (p.y >= h) p.y -= h;

      const life = Math.min(1, p.age / 60);
      const alpha = life * 0.45;
      const r = Math.floor(40 + 60 * life);
      const g = Math.floor(180 + 40 * life);
      const b = Math.floor(120 + 30 * life);
      ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
      ctx.fillRect(Math.floor(p.x), Math.floor(p.y), 1, 1);

      if (p.age > 200 + Math.random() * 100) {
        p.x = Math.random() * w;
        p.y = Math.random() * h;
        p.age = 0;
      }
    }

    requestAnimationFrame(frame);
  }
  frame();
})();

// --- Morphogenesis thumbnail: animated pattern texture ---
(function() {
  const cv = document.getElementById('cv-rd');
  const ctx = cv.getContext('2d');
  let w, h;

  function resize() {
    const rect = cv.parentElement.getBoundingClientRect();
    w = cv.width = Math.floor(rect.width * 0.5);
    h = cv.height = Math.floor(rect.height * 0.5);
    cv.style.imageRendering = 'auto';
  }
  resize();
  window.addEventListener('resize', resize);

  // Simplified reaction-diffusion on a small grid
  const gw = 128, gh = 64;
  let U = new Float32Array(gw * gh);
  let V = new Float32Array(gw * gh);
  let U2 = new Float32Array(gw * gh);
  let V2 = new Float32Array(gw * gh);

  // Init
  for (let i = 0; i < gw * gh; i++) {
    U[i] = 1.0;
    V[i] = 0.0;
  }

  // Seed center region
  const cx = gw / 2, cy = gh / 2;
  for (let y = -5; y <= 5; y++) {
    for (let x = -5; x <= 5; x++) {
      if (x*x + y*y > 25) continue;
      const idx = (Math.floor(cy + y)) * gw + Math.floor(cx + x);
      U[idx] = 0.5;
      V[idx] = 0.25 + Math.random() * 0.05;
    }
  }

  const f = 0.0367, k = 0.0649;
  const Du = 0.2097, Dv = 0.105;

  function step() {
    for (let y = 0; y < gh; y++) {
      for (let x = 0; x < gw; x++) {
        const i = y * gw + x;
        const l = y * gw + ((x - 1 + gw) % gw);
        const r = y * gw + ((x + 1) % gw);
        const t = ((y - 1 + gh) % gh) * gw + x;
        const b = ((y + 1) % gh) * gw + x;

        const lapU = U[l] + U[r] + U[t] + U[b] - 4 * U[i];
        const lapV = V[l] + V[r] + V[t] + V[b] - 4 * V[i];
        const uvv = U[i] * V[i] * V[i];

        U2[i] = Math.max(0, Math.min(1, U[i] + Du * lapU - uvv + f * (1 - U[i])));
        V2[i] = Math.max(0, Math.min(1, V[i] + Dv * lapV + uvv - (f + k) * V[i]));
      }
    }
    [U, U2] = [U2, U];
    [V, V2] = [V2, V];
  }

  // Offscreen canvas for scaling up the small sim grid
  const offscreen = document.createElement('canvas');
  offscreen.width = gw;
  offscreen.height = gh;
  const offCtx = offscreen.getContext('2d');
  const img = offCtx.createImageData(gw, gh);

  function render() {
    for (let i = 0; i < gw * gh; i++) {
      const t = Math.min(1, V[i] / 0.32);
      const t2 = t * t;
      // Mitosis palette: dark violet -> magenta -> pale rose
      img.data[i * 4]     = Math.floor((0.04 + t * 0.71 + t2 * 0.25) * 255);
      img.data[i * 4 + 1] = Math.floor((0.01 + t * 0.11 + t2 * 0.7) * 255);
      img.data[i * 4 + 2] = Math.floor((0.1 + t * 0.45 + t2 * 0.33) * 255);
      img.data[i * 4 + 3] = 255;
    }
    offCtx.putImageData(img, 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(offscreen, 0, 0, w, h);
  }

  function frame() {
    for (let i = 0; i < 8; i++) step();
    render();
    requestAnimationFrame(frame);
  }
  frame();
})();

// --- Strange Attractor thumbnail: Lorenz butterfly ---
(function() {
  const cv = document.getElementById('cv-sa');
  const ctx = cv.getContext('2d');
  let w, h;

  function resize() {
    const rect = cv.parentElement.getBoundingClientRect();
    w = cv.width = Math.floor(rect.width);
    h = cv.height = Math.floor(rect.height);
  }
  resize();
  window.addEventListener('resize', resize);

  // Lorenz system
  const sigma = 10, rho = 28, beta = 8/3;
  const N = 30, TRAIL = 120;
  let trails = [];

  function init() {
    trails = [];
    for (let i = 0; i < N; i++) {
      trails.push({
        pts: [[
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5,
          25 + (Math.random() - 0.5) * 0.5
        ]],
        hue: Math.random(),
      });
    }
  }
  init();

  let rotY = 0;

  function frame() {
    ctx.fillStyle = 'rgba(5,5,8,0.12)';
    ctx.fillRect(0, 0, w, h);

    rotY += 0.003;
    const cosR = Math.cos(rotY), sinR = Math.sin(rotY);
    const cosX = Math.cos(-0.35), sinX = Math.sin(-0.35);
    const scale = Math.min(w, h) * 0.15;
    const dt = 0.005;

    for (const trail of trails) {
      const last = trail.pts[trail.pts.length - 1];
      const [x, y, z] = last;

      // Euler integration (fine for thumbnail)
      const dx = sigma * (y - x);
      const dy = x * (rho - z) - y;
      const dz = x * y - beta * z;
      trail.pts.push([x + dx*dt, y + dy*dt, z + dz*dt]);
      if (trail.pts.length > TRAIL) trail.pts.shift();

      // Draw trail
      ctx.beginPath();
      let started = false;
      for (const p of trail.pts) {
        const px = p[0], py = p[1], pz = p[2] - 25;
        // Rotate Y then X
        const rx = px * cosR + pz * sinR;
        const rz = -px * sinR + pz * cosR;
        const ry2 = py * cosX - rz * sinX;

        const sx = w/2 + rx * scale;
        const sy = h/2 + ry2 * scale;

        if (!started) { ctx.moveTo(sx, sy); started = true; }
        else ctx.lineTo(sx, sy);
      }

      const r = Math.floor((50 + trail.hue * 150));
      const g = Math.floor((100 + trail.hue * 140));
      const b = Math.floor((200 + trail.hue * 55));
      ctx.strokeStyle = `rgba(${r},${g},${b},0.5)`;
      ctx.lineWidth = 0.6;
      ctx.stroke();
    }

    requestAnimationFrame(frame);
  }
  frame();
})();

// --- Particle Life thumbnail: colored particles self-organizing ---
(function() {
  const cv = document.getElementById('cv-pl');
  const ctx = cv.getContext('2d');
  let w, h;

  function resize() {
    const rect = cv.parentElement.getBoundingClientRect();
    w = cv.width = Math.floor(rect.width);
    h = cv.height = Math.floor(rect.height);
    init();
  }

  const TYPES = 5;
  const N = 200;
  const COLORS = [
    [255, 80, 80],
    [80, 200, 255],
    [120, 255, 120],
    [255, 200, 60],
    [200, 100, 255],
  ];

  let ppx, ppy, pvx, pvy, ptype;
  let matrix;

  function init() {
    ppx = new Float32Array(N);
    ppy = new Float32Array(N);
    pvx = new Float32Array(N);
    pvy = new Float32Array(N);
    ptype = new Uint8Array(N);

    for (let i = 0; i < N; i++) {
      ppx[i] = Math.random() * w;
      ppy[i] = Math.random() * h;
      pvx[i] = 0;
      pvy[i] = 0;
      ptype[i] = Math.floor(Math.random() * TYPES);
    }

    // Random attraction matrix
    matrix = [];
    for (let i = 0; i < TYPES; i++) {
      matrix[i] = [];
      for (let j = 0; j < TYPES; j++) {
        matrix[i][j] = Math.random() * 2 - 1;
      }
    }
  }

  resize();
  window.addEventListener('resize', resize);

  const RMAX = 60;
  const BETA = 0.3;
  const FRICTION = 0.05;

  function frame() {
    ctx.fillStyle = 'rgba(5,5,8,0.15)';
    ctx.fillRect(0, 0, w, h);

    // Simple O(n^2) — fine for 200 particles
    for (let i = 0; i < N; i++) {
      let fx = 0, fy = 0;
      for (let j = 0; j < N; j++) {
        if (i === j) continue;
        let dx = ppx[j] - ppx[i];
        let dy = ppy[j] - ppy[i];
        // Wrap
        if (dx > w/2) dx -= w; else if (dx < -w/2) dx += w;
        if (dy > h/2) dy -= h; else if (dy < -h/2) dy += h;
        const d = Math.sqrt(dx*dx + dy*dy);
        if (d > 0 && d < RMAX) {
          const nd = d / RMAX;
          let f;
          if (nd < BETA) {
            f = nd / BETA - 1;
          } else {
            const t = (nd - BETA) / (1 - BETA);
            f = matrix[ptype[i]][ptype[j]] * (1 - Math.abs(2*t - 1));
          }
          const mag = f * 0.3 / d;
          fx += dx * mag;
          fy += dy * mag;
        }
      }
      pvx[i] = (pvx[i] + fx) * (1 - FRICTION);
      pvy[i] = (pvy[i] + fy) * (1 - FRICTION);
    }

    for (let i = 0; i < N; i++) {
      ppx[i] += pvx[i];
      ppy[i] += pvy[i];
      if (ppx[i] < 0) ppx[i] += w;
      else if (ppx[i] >= w) ppx[i] -= w;
      if (ppy[i] < 0) ppy[i] += h;
      else if (ppy[i] >= h) ppy[i] -= h;

      const [r, g, b] = COLORS[ptype[i]];
      ctx.fillStyle = `rgba(${r},${g},${b},0.8)`;
      ctx.fillRect(Math.floor(ppx[i]), Math.floor(ppy[i]), 2, 2);
    }

    requestAnimationFrame(frame);
  }
  frame();
})();

// --- Murmuration thumbnail: flocking text characters ---
(function() {
  const cv = document.getElementById('cv-mu');
  const ctx = cv.getContext('2d');
  let w, h;

  function resize() {
    const rect = cv.parentElement.getBoundingClientRect();
    w = cv.width = Math.floor(rect.width);
    h = cv.height = Math.floor(rect.height);
    init();
  }

  const N = 120;
  const ALPHA = 'abcdefghijklmnopqrstuvwxyz';
  let px, py, pvx, pvy, pch;

  function init() {
    px = new Float32Array(N);
    py = new Float32Array(N);
    pvx = new Float32Array(N);
    pvy = new Float32Array(N);
    pch = [];
    for (let i = 0; i < N; i++) {
      px[i] = Math.random() * w;
      py[i] = Math.random() * h;
      pvx[i] = (Math.random() - 0.5) * 0.8;
      pvy[i] = (Math.random() - 0.5) * 0.8;
      pch[i] = ALPHA[Math.floor(Math.random() * ALPHA.length)];
    }
  }

  resize();
  window.addEventListener('resize', resize);

  const SEP_R = 14, ALN_R = 35, COH_R = 60;
  const SEP_S = 1.5, ALN_S = 0.06, COH_S = 0.003;
  const FRIC = 0.96;

  let time = 0;

  function frame() {
    ctx.fillStyle = 'rgba(8,8,12,0.88)';
    ctx.fillRect(0, 0, w, h);
    time += 0.016;

    for (let i = 0; i < N; i++) {
      let ax = 0, ay = 0;
      let sx = 0, sy = 0, sn = 0;
      let alx = 0, aly = 0, aln = 0;
      let cx = 0, cy = 0, cn = 0;

      for (let j = 0; j < N; j++) {
        if (i === j) continue;
        const dx = px[j] - px[i], dy = py[j] - py[i];
        const d2 = dx * dx + dy * dy;
        if (d2 < SEP_R * SEP_R && d2 > 0.1) {
          const d = Math.sqrt(d2);
          sx -= dx / d; sy -= dy / d; sn++;
        }
        if (d2 < ALN_R * ALN_R) { alx += pvx[j]; aly += pvy[j]; aln++; }
        if (d2 < COH_R * COH_R) { cx += px[j]; cy += py[j]; cn++; }
      }

      if (sn > 0) { ax += sx / sn * SEP_S; ay += sy / sn * SEP_S; }
      if (aln > 0) { ax += (alx / aln - pvx[i]) * ALN_S; ay += (aly / aln - pvy[i]) * ALN_S; }
      if (cn > 0) { ax += (cx / cn - px[i]) * COH_S; ay += (cy / cn - py[i]) * COH_S; }

      // Gentle turbulence
      ax += Math.sin(py[i] * 0.01 + time * 0.5 + i) * 0.15;
      ay += Math.cos(px[i] * 0.01 + time * 0.4 + i) * 0.15;

      // Boundary
      if (px[i] < 20) ax += 0.3; else if (px[i] > w - 20) ax -= 0.3;
      if (py[i] < 15) ay += 0.3; else if (py[i] > h - 15) ay -= 0.3;

      pvx[i] = (pvx[i] + ax * 0.016) * FRIC;
      pvy[i] = (pvy[i] + ay * 0.016) * FRIC;
      const spd = Math.sqrt(pvx[i] * pvx[i] + pvy[i] * pvy[i]);
      if (spd > 2) { pvx[i] = pvx[i] / spd * 2; pvy[i] = pvy[i] / spd * 2; }
      px[i] += pvx[i];
      py[i] += pvy[i];
    }

    ctx.font = '10px Courier New, monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    for (let i = 0; i < N; i++) {
      const b = 0.25 + Math.sin(time * 0.7 + i * 0.5) * 0.08;
      const g = Math.floor((170 + 40 * b));
      const bl = Math.floor((190 + 40 * b));
      ctx.fillStyle = `rgba(${Math.floor(160 * b)},${g},${bl},${b})`;
      ctx.fillText(pch[i], px[i], py[i]);
    }

    requestAnimationFrame(frame);
  }
  frame();
})();

// --- Neural Automaton thumbnail: spiking network ---
(function() {
  const cv = document.getElementById('cv-na');
  const ctx = cv.getContext('2d');
  let w, h;

  const N = 60;
  const TWO_PI = Math.PI * 2;
  let nx, ny, nv, nflash, ninhib;
  let edges, edgeW, edgeActive;

  function resize() {
    const rect = cv.parentElement.getBoundingClientRect();
    w = cv.width = Math.floor(rect.width);
    h = cv.height = Math.floor(rect.height);
    init();
  }

  function init() {
    nx = new Float32Array(N);
    ny = new Float32Array(N);
    nv = new Float32Array(N);
    nflash = new Float32Array(N);
    ninhib = new Uint8Array(N);

    for (let i = 0; i < N; i++) {
      nx[i] = 20 + Math.random() * (w - 40);
      ny[i] = 15 + Math.random() * (h - 30);
      nv[i] = Math.random() * 0.3;
      nflash[i] = 0;
      ninhib[i] = Math.random() < 0.2 ? 1 : 0;
    }

    // Relax positions
    for (let iter = 0; iter < 40; iter++) {
      for (let i = 0; i < N; i++) {
        let fx = 0, fy = 0;
        for (let j = 0; j < N; j++) {
          if (i === j) continue;
          const dx = nx[i] - nx[j];
          const dy = ny[i] - ny[j];
          const d = Math.sqrt(dx * dx + dy * dy) + 0.1;
          if (d < 30) {
            const f = (30 - d) * 0.08;
            fx += (dx / d) * f;
            fy += (dy / d) * f;
          }
        }
        nx[i] = Math.max(10, Math.min(w - 10, nx[i] + fx));
        ny[i] = Math.max(10, Math.min(h - 10, ny[i] + fy));
      }
    }

    // Create edges (nearby connections)
    edges = [];
    edgeW = [];
    edgeActive = [];
    for (let i = 0; i < N; i++) {
      const dists = [];
      for (let j = 0; j < N; j++) {
        if (i === j) continue;
        const dx = nx[i] - nx[j];
        const dy = ny[i] - ny[j];
        dists.push({ j, d: Math.sqrt(dx * dx + dy * dy) });
      }
      dists.sort((a, b) => a.d - b.d);
      const count = 2 + Math.floor(Math.random() * 3);
      for (let k = 0; k < Math.min(count, dists.length); k++) {
        if (dists[k].d < 150) {
          edges.push([i, dists[k].j]);
          edgeW.push(0.1 + Math.random() * 0.3);
          edgeActive.push(0);
        }
      }
    }
  }

  resize();
  window.addEventListener('resize', resize);

  function frame() {
    ctx.fillStyle = '#050508';
    ctx.fillRect(0, 0, w, h);

    // Spontaneous activity
    for (let i = 0; i < N; i++) {
      nv[i] += (Math.random() - 0.48) * 0.02;
      nv[i] *= 0.995;
      nflash[i] *= 0.9;
    }

    // Check for fires
    for (let i = 0; i < N; i++) {
      if (nv[i] > 0.7) {
        nv[i] = 0;
        nflash[i] = 1;
        // Propagate
        for (let e = 0; e < edges.length; e++) {
          if (edges[e][0] === i) {
            nv[edges[e][1]] += edgeW[e] * (ninhib[i] ? -0.3 : 0.4);
            edgeActive[e] = 1;
            // Strengthen
            edgeW[e] = Math.min(0.8, edgeW[e] + 0.01);
          }
        }
      }
      nv[i] = Math.max(-0.2, Math.min(1, nv[i]));
    }

    // Decay edge activity
    for (let e = 0; e < edges.length; e++) {
      edgeActive[e] *= 0.88;
    }

    // Draw edges
    for (let e = 0; e < edges.length; e++) {
      const [i, j] = edges[e];
      const act = edgeActive[e];
      const alpha = edgeW[e] * 0.2 + act * 0.5;
      if (alpha < 0.02) continue;
      ctx.beginPath();
      ctx.moveTo(nx[i], ny[i]);
      ctx.lineTo(nx[j], ny[j]);
      const r = Math.floor(60 + act * 140);
      const g = Math.floor(80 + act * 140);
      const b = Math.floor(160 + act * 95);
      ctx.strokeStyle = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
      ctx.lineWidth = 0.3 + edgeW[e] + act * 1.2;
      ctx.stroke();
    }

    // Draw neurons
    for (let i = 0; i < N; i++) {
      const flash = nflash[i];
      const v = Math.max(0, nv[i]);
      const radius = 2 + flash * 3;

      if (flash > 0.3) {
        const glow = ctx.createRadialGradient(nx[i], ny[i], 1, nx[i], ny[i], radius + flash * 8);
        if (ninhib[i]) {
          glow.addColorStop(0, `rgba(255,120,140,${flash * 0.2})`);
        } else {
          glow.addColorStop(0, `rgba(140,180,255,${flash * 0.25})`);
        }
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(nx[i], ny[i], radius + flash * 8, 0, TWO_PI);
        ctx.fill();
      }

      let r, g, b;
      if (ninhib[i]) {
        r = 160 + flash * 95; g = 50 + flash * 80; b = 70 + flash * 70;
      } else {
        r = 60 + flash * 180; g = 100 + flash * 155; b = 180 + flash * 75;
      }
      const a = 0.3 + v * 0.3 + flash * 0.4;
      ctx.fillStyle = `rgba(${Math.floor(r)},${Math.floor(g)},${Math.floor(b)},${a.toFixed(3)})`;
      ctx.beginPath();
      ctx.arc(nx[i], ny[i], radius, 0, TWO_PI);
      ctx.fill();
    }

    requestAnimationFrame(frame);
  }
  frame();
})();

// --- Physarum thumbnail: slime mold network ---
(function() {
  const cv = document.getElementById('cv-ph');
  const ctx = cv.getContext('2d');
  let w, h;

  function resize() {
    const rect = cv.parentElement.getBoundingClientRect();
    w = cv.width = Math.floor(rect.width * 0.5);
    h = cv.height = Math.floor(rect.height * 0.5);
    cv.style.imageRendering = 'auto';
    init();
  }

  const TW = 128, TH = 64;
  const NA = 4000;
  let agX, agY, agA;
  let trail, trail2;

  function init() {
    agX = new Float32Array(NA);
    agY = new Float32Array(NA);
    agA = new Float32Array(NA);
    trail = new Float32Array(TW * TH);
    trail2 = new Float32Array(TW * TH);

    for (let i = 0; i < NA; i++) {
      agX[i] = Math.random() * TW;
      agY[i] = Math.random() * TH;
      agA[i] = Math.random() * Math.PI * 2;
    }
  }

  const SA = 0.785, SD = 6, TS = 0.785, MS = 0.8, DEP = 3, DECAY = 0.92;

  function sense(x, y) {
    const ix = ((Math.floor(x) % TW) + TW) % TW;
    const iy = ((Math.floor(y) % TH) + TH) % TH;
    return trail[iy * TW + ix];
  }

  function step() {
    for (let i = 0; i < NA; i++) {
      const sL = sense(agX[i] + Math.cos(agA[i] - SA) * SD, agY[i] + Math.sin(agA[i] - SA) * SD);
      const sC = sense(agX[i] + Math.cos(agA[i]) * SD, agY[i] + Math.sin(agA[i]) * SD);
      const sR = sense(agX[i] + Math.cos(agA[i] + SA) * SD, agY[i] + Math.sin(agA[i] + SA) * SD);

      if (sC > sL && sC > sR) {
        // straight
      } else if (sC < sL && sC < sR) {
        agA[i] += (Math.random() - 0.5) * TS * 2;
      } else if (sL > sR) {
        agA[i] -= TS;
      } else {
        agA[i] += TS;
      }

      agX[i] = ((agX[i] + Math.cos(agA[i]) * MS) % TW + TW) % TW;
      agY[i] = ((agY[i] + Math.sin(agA[i]) * MS) % TH + TH) % TH;

      const ix = Math.floor(agX[i]);
      const iy = Math.floor(agY[i]);
      if (ix >= 0 && ix < TW && iy >= 0 && iy < TH) {
        trail[iy * TW + ix] += DEP;
      }
    }

    for (let y = 0; y < TH; y++) {
      for (let x = 0; x < TW; x++) {
        let sum = 0;
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            sum += trail[((y + dy + TH) % TH) * TW + ((x + dx + TW) % TW)];
          }
        }
        trail2[y * TW + x] = (sum / 9) * DECAY;
      }
    }
    [trail, trail2] = [trail2, trail];
  }

  const offscreen = document.createElement('canvas');
  offscreen.width = TW;
  offscreen.height = TH;
  const offCtx = offscreen.getContext('2d');
  const img = offCtx.createImageData(TW, TH);

  function render() {
    for (let i = 0; i < TW * TH; i++) {
      let t = Math.min(1, trail[i] * 0.04);
      t = Math.pow(t, 0.7);
      img.data[i * 4]     = Math.floor((0.02 + t * 0.76 + t * t * 0.22) * 255);
      img.data[i * 4 + 1] = Math.floor((0.015 + t * 0.565 + t * t * 0.42) * 255);
      img.data[i * 4 + 2] = Math.floor((0.01 + t * 0.11 + t * t * 0.83) * 255);
      img.data[i * 4 + 3] = 255;
    }
    offCtx.putImageData(img, 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(offscreen, 0, 0, w, h);
  }

  resize();
  window.addEventListener('resize', resize);

  function frame() {
    for (let i = 0; i < 3; i++) step();
    render();
    requestAnimationFrame(frame);
  }
  frame();
})();
</script>

</body>
</html>
