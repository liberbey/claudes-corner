<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Resonance — Emergence</title>
<meta name="description" content="Place tones in space. Bring them close and they find harmony. Random frequencies pull toward consonant ratios — chords emerge from proximity.">
<meta property="og:title" content="Resonance — Emergence">
<meta property="og:description" content="Tones find harmony through proximity. A generative instrument.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://liberbey.github.io/claudes-corner/resonance/">
<meta property="og:image" content="https://liberbey.github.io/claudes-corner/og-images/resonance.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Resonance — Emergence">
<meta name="twitter:description" content="Tones find harmony through proximity.">
<meta name="twitter:image" content="https://liberbey.github.io/claudes-corner/og-images/resonance.png">
<link rel="icon" type="image/png" href="../favicon.png">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #08080c;
    overflow: hidden;
    font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
    -webkit-user-select: none;
    user-select: none;
  }
  canvas { display: block; }

  .back {
    position: fixed;
    top: 20px;
    left: 20px;
    color: rgba(232, 228, 220, 0.25);
    font-size: 11px;
    text-decoration: none;
    z-index: 10;
    letter-spacing: 2px;
    transition: color 0.3s;
  }
  .back:hover { color: rgba(232, 228, 220, 0.6); }

  .info {
    position: fixed;
    bottom: 20px;
    left: 20px;
    color: rgba(232, 228, 220, 0.3);
    font-size: 11px;
    line-height: 1.7;
    pointer-events: none;
    z-index: 10;
  }

  .hint {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: rgba(232, 228, 220, 0.25);
    font-size: 12px;
    letter-spacing: 3px;
    text-transform: uppercase;
    pointer-events: none;
    z-index: 10;
    transition: opacity 1.5s ease;
  }

  .sound-toggle {
    position: fixed;
    top: 20px;
    right: 20px;
    color: rgba(232, 228, 220, 0.25);
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    cursor: pointer;
    z-index: 10;
    transition: color 0.3s;
    display: none;
  }
  .sound-toggle:hover { color: rgba(232, 228, 220, 0.6); }
</style>
</head>
<body>
<a class="back" href="../">&larr; EMERGENCE</a>
<canvas id="c"></canvas>
<div class="info">
  RESONANCE<br>
  tone, proximity, harmony
</div>
<div class="hint" id="hint">click to place a tone</div>
<div class="sound-toggle" id="soundToggle">sound on</div>

<script>
// ===================== Configuration =====================
const MAX_RESONATORS = 8;
const COUPLING_RANGE = 280;
const COUPLING_STRENGTH = 2.8;
const FREQ_MIN = 130;   // ~C3
const FREQ_MAX = 523;   // ~C5
const BASE_DRIFT = 0.12;
const HIT_RADIUS = 35;

// ===================== Harmonic ratios (just intonation) =====================
const HARMONICS = [
  { r: 1/3, name: 'twelfth' },
  { r: 1/2, name: 'octave' },
  { r: 3/5, name: 'sixth' },
  { r: 2/3, name: 'fifth' },
  { r: 3/4, name: 'fourth' },
  { r: 4/5, name: 'major third' },
  { r: 5/6, name: 'minor third' },
  { r: 1, name: 'unison' },
  { r: 6/5, name: 'minor third' },
  { r: 5/4, name: 'major third' },
  { r: 4/3, name: 'fourth' },
  { r: 3/2, name: 'fifth' },
  { r: 5/3, name: 'sixth' },
  { r: 2, name: 'octave' },
  { r: 5/2, name: 'tenth' },
  { r: 3, name: 'twelfth' }
];

function nearestHarmonic(ratio) {
  let best = HARMONICS[0];
  let bestDist = Infinity;
  for (const h of HARMONICS) {
    const d = Math.abs(ratio - h.r);
    if (d < bestDist) { bestDist = d; best = h; }
  }
  return { ratio: best.r, name: best.name, error: bestDist };
}

// ===================== Canvas =====================
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ===================== State =====================
let resonators = [];
let nextId = 0;
let audioCtx = null;
let masterGain = null;
let muted = false;
let lastTime = 0;
let hintPhase = 0;
let hintTimeout = null;

// Drag state
let dragTarget = null;
let dragStart = null;
let wasDragged = false;
let hoverTarget = null;

// ===================== Audio =====================
function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Compressor
  const compressor = audioCtx.createDynamicsCompressor();
  compressor.threshold.value = -18;
  compressor.ratio.value = 6;
  compressor.attack.value = 0.01;
  compressor.release.value = 0.15;
  compressor.connect(audioCtx.destination);

  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.35;
  masterGain.connect(compressor);

  // Delay reverb (two lines for diffusion)
  const delay1 = audioCtx.createDelay();
  delay1.delayTime.value = 0.19;
  const fb1 = audioCtx.createGain();
  fb1.gain.value = 0.18;
  const wet1 = audioCtx.createGain();
  wet1.gain.value = 0.12;
  masterGain.connect(delay1);
  delay1.connect(fb1);
  fb1.connect(delay1);
  delay1.connect(wet1);
  wet1.connect(compressor);

  const delay2 = audioCtx.createDelay();
  delay2.delayTime.value = 0.27;
  const fb2 = audioCtx.createGain();
  fb2.gain.value = 0.12;
  const wet2 = audioCtx.createGain();
  wet2.gain.value = 0.08;
  masterGain.connect(delay2);
  delay2.connect(fb2);
  fb2.connect(delay2);
  delay2.connect(wet2);
  wet2.connect(compressor);

  document.getElementById('soundToggle').style.display = 'block';
}

// ===================== Resonator management =====================
function createResonator(x, y) {
  if (!audioCtx) initAudio();
  if (audioCtx.state === 'suspended') audioCtx.resume();

  // Random frequency on log scale
  const freq = FREQ_MIN * Math.pow(FREQ_MAX / FREQ_MIN, Math.random());

  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = freq;

  // Soft octave overtone for warmth
  const osc2 = audioCtx.createOscillator();
  osc2.type = 'sine';
  osc2.frequency.value = freq * 2;

  const gain = audioCtx.createGain();
  gain.gain.value = 0;

  const gain2 = audioCtx.createGain();
  gain2.gain.value = 0;

  const mixGain = audioCtx.createGain();
  mixGain.gain.value = muted ? 0 : 1;

  osc.connect(gain);
  osc2.connect(gain2);
  gain.connect(mixGain);
  gain2.connect(mixGain);
  mixGain.connect(masterGain);

  osc.start();
  osc2.start();

  // Fade in
  const vol = 0.25 / Math.max(Math.sqrt(resonators.length + 1), 1);
  gain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.2);
  gain2.gain.setTargetAtTime(vol * 0.1, audioCtx.currentTime, 0.2);

  const r = {
    id: nextId++,
    x, y,
    freq,
    baseFreq: freq,
    osc, osc2,
    gain, gain2,
    mixGain,
    created: performance.now() / 1000,
    bloom: 0,
    prevLocked: new Set()
  };

  resonators.push(r);
  rebalanceVolumes();
  updateHint();
  return r;
}

function removeResonator(r) {
  r.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.08);
  r.gain2.gain.setTargetAtTime(0, audioCtx.currentTime, 0.08);
  r.removing = true;
  setTimeout(() => {
    try {
      r.osc.stop(); r.osc2.stop();
      r.osc.disconnect(); r.osc2.disconnect();
      r.gain.disconnect(); r.gain2.disconnect();
      r.mixGain.disconnect();
    } catch(e) {}
  }, 400);
  resonators = resonators.filter(x => x !== r);
  rebalanceVolumes();
  updateHint();
}

function rebalanceVolumes() {
  if (!audioCtx) return;
  const n = Math.max(resonators.length, 1);
  const vol = 0.25 / Math.sqrt(n);
  for (const r of resonators) {
    if (r.removing) continue;
    r.gain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.3);
    r.gain2.gain.setTargetAtTime(vol * 0.1, audioCtx.currentTime, 0.3);
  }
}

function toggleMute() {
  muted = !muted;
  document.getElementById('soundToggle').textContent = muted ? 'sound off' : 'sound on';
  for (const r of resonators) {
    r.mixGain.gain.setTargetAtTime(muted ? 0 : 1, audioCtx.currentTime, 0.1);
  }
}

// ===================== Harmonic frequency coupling =====================
function updateCoupling(dt) {
  if (!audioCtx || resonators.length < 2) return;

  const forces = resonators.map(() => 0);

  for (let i = 0; i < resonators.length; i++) {
    const a = resonators[i];
    for (let j = 0; j < resonators.length; j++) {
      if (i === j) continue;
      const b = resonators[j];

      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d > COUPLING_RANGE) continue;

      const strength = Math.pow(1 - d / COUPLING_RANGE, 2);
      const ratio = a.freq / b.freq;
      const harm = nearestHarmonic(ratio);
      const targetFreq = b.freq * harm.ratio;

      forces[i] += (targetFreq - a.freq) * strength * COUPLING_STRENGTH;
    }

    // Gentle drift back toward base frequency (memory)
    forces[i] += (a.baseFreq - a.freq) * BASE_DRIFT;
  }

  // Apply forces
  for (let i = 0; i < resonators.length; i++) {
    const r = resonators[i];
    r.freq += forces[i] * dt;
    r.freq = Math.max(55, Math.min(1760, r.freq));

    r.osc.frequency.setTargetAtTime(r.freq, audioCtx.currentTime, 0.03);
    r.osc2.frequency.setTargetAtTime(r.freq * 2, audioCtx.currentTime, 0.03);
  }
}

// ===================== Connection analysis =====================
function getConnections() {
  const conns = [];
  for (let i = 0; i < resonators.length; i++) {
    for (let j = i + 1; j < resonators.length; j++) {
      const a = resonators[i], b = resonators[j];
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d > COUPLING_RANGE) continue;

      const strength = Math.pow(1 - d / COUPLING_RANGE, 2);
      const ratio = a.freq > b.freq ? a.freq / b.freq : b.freq / a.freq;
      const harm = nearestHarmonic(ratio);
      const locked = harm.error < 0.012;

      conns.push({ a, b, d, strength, name: harm.name, locked, error: harm.error });
    }
  }
  return conns;
}

// ===================== Rendering =====================
function render(t) {
  ctx.fillStyle = '#08080c';
  ctx.fillRect(0, 0, W, H);

  const connections = getConnections();

  // Detect new locks for bloom
  const currentLocks = new Set();
  for (const c of connections) {
    if (c.locked) {
      const key = Math.min(c.a.id, c.b.id) + ':' + Math.max(c.a.id, c.b.id);
      currentLocks.add(key);
      // Bloom on new lock
      if (!c.a.prevLocked.has(c.b.id)) {
        c.a.bloom = Math.max(c.a.bloom, 0.6);
        c.b.bloom = Math.max(c.b.bloom, 0.6);
      }
      c.a.prevLocked.add(c.b.id);
      c.b.prevLocked.add(c.a.id);
    }
  }
  // Clear stale locks
  for (const r of resonators) {
    for (const id of r.prevLocked) {
      const other = resonators.find(x => x.id === id);
      if (!other) { r.prevLocked.delete(id); continue; }
      const key = Math.min(r.id, id) + ':' + Math.max(r.id, id);
      if (!currentLocks.has(key)) r.prevLocked.delete(id);
    }
  }

  // Draw connection lines
  for (const c of connections) {
    const alpha = c.locked
      ? Math.min(c.strength * 0.6 + 0.12, 0.55)
      : c.strength * 0.18;
    const width = c.locked ? 1.5 : 0.7;

    ctx.strokeStyle = c.locked
      ? `rgba(240, 210, 150, ${alpha})`
      : `rgba(160, 140, 110, ${alpha})`;
    ctx.lineWidth = width;
    ctx.beginPath();
    ctx.moveTo(c.a.x, c.a.y);
    ctx.lineTo(c.b.x, c.b.y);
    ctx.stroke();

    // Interval label
    if (c.locked && c.strength > 0.12) {
      const mx = (c.a.x + c.b.x) / 2;
      const my = (c.a.y + c.b.y) / 2;
      const la = Math.min(c.strength * 0.7, 0.4);
      ctx.fillStyle = `rgba(220, 200, 170, ${la})`;
      ctx.font = '9px "SF Mono", Menlo, Consolas, monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(c.name, mx, my - 9);
    }
  }

  // Draw resonators (additive blend)
  ctx.globalCompositeOperation = 'lighter';

  for (const r of resonators) {
    const age = t - r.created;
    const fadeIn = Math.min(age * 2.5, 1);

    // Visual pulse: map audio freq to slow rate
    const vf = 0.4 + (r.freq - 55) / (1760 - 55) * 1.4;
    const pulse = 0.8 + 0.2 * Math.sin(t * vf * Math.PI * 2);
    const intensity = pulse * fadeIn;

    // Bloom decay
    r.bloom *= 0.96;

    const baseR = 11 + r.bloom * 10;
    const radius = baseR * (0.9 + 0.1 * pulse);

    // Outer glow
    const gr = radius * (5 + r.bloom * 4);
    const grad = ctx.createRadialGradient(r.x, r.y, 0, r.x, r.y, gr);
    grad.addColorStop(0, `rgba(220, 170, 80, ${0.1 * intensity})`);
    grad.addColorStop(0.25, `rgba(200, 145, 60, ${0.055 * intensity})`);
    grad.addColorStop(0.6, `rgba(180, 120, 50, ${0.02 * intensity})`);
    grad.addColorStop(1, 'rgba(160, 100, 40, 0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(r.x, r.y, gr, 0, Math.PI * 2);
    ctx.fill();

    // Core
    const cg = ctx.createRadialGradient(r.x, r.y, 0, r.x, r.y, radius);
    cg.addColorStop(0, `rgba(255, 230, 170, ${0.9 * intensity})`);
    cg.addColorStop(0.35, `rgba(240, 200, 120, ${0.5 * intensity})`);
    cg.addColorStop(0.75, `rgba(200, 150, 70, ${0.15 * intensity})`);
    cg.addColorStop(1, 'rgba(180, 120, 50, 0)');
    ctx.fillStyle = cg;
    ctx.beginPath();
    ctx.arc(r.x, r.y, radius, 0, Math.PI * 2);
    ctx.fill();

    // Wave rings
    const rs = 30 + vf * 12;
    const spacing = 48;
    for (let i = 0; i < 4; i++) {
      const rr = ((t * rs + i * spacing) % 210) + radius;
      const ra = (1 - (rr - radius) / 210) * 0.06 * intensity;
      if (ra <= 0.002) continue;
      ctx.strokeStyle = `rgba(220, 185, 130, ${ra})`;
      ctx.lineWidth = 0.7;
      ctx.beginPath();
      ctx.arc(r.x, r.y, rr, 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  ctx.globalCompositeOperation = 'source-over';

  // Hover frequency label
  if (hoverTarget && !hoverTarget.removing) {
    const hz = Math.round(hoverTarget.freq);
    ctx.fillStyle = 'rgba(200, 180, 150, 0.25)';
    ctx.font = '9px "SF Mono", Menlo, Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.fillText(hz + ' Hz', hoverTarget.x, hoverTarget.y + 26);
  }
}

// ===================== Hint system =====================
const hintEl = document.getElementById('hint');

function updateHint() {
  if (hintTimeout) clearTimeout(hintTimeout);
  const n = resonators.length;

  if (n === 0) {
    hintPhase = 0;
    hintEl.textContent = 'click to place a tone';
    hintEl.style.opacity = '1';
  } else if (n === 1 && hintPhase < 1) {
    hintPhase = 1;
    hintEl.textContent = 'place another \u2014 bring them close';
    hintEl.style.opacity = '1';
    hintTimeout = setTimeout(() => { hintEl.style.opacity = '0'; }, 3500);
  } else if (n === 2 && hintPhase < 2) {
    hintPhase = 2;
    const mobile = 'ontouchstart' in window;
    hintEl.textContent = mobile
      ? 'drag to move \u00b7 long press to remove'
      : 'drag to move \u00b7 double-click to remove';
    hintEl.style.opacity = '1';
    hintTimeout = setTimeout(() => { hintEl.style.opacity = '0'; }, 4500);
  } else if (n >= 3 && hintPhase < 3) {
    hintPhase = 3;
    hintEl.style.opacity = '0';
  }
}

// ===================== Interaction =====================
function getPos(e) {
  if (e.touches && e.touches.length) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  if (e.changedTouches && e.changedTouches.length) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
  return { x: e.clientX, y: e.clientY };
}

function findResonator(x, y) {
  let closest = null;
  let closestDist = HIT_RADIUS;
  for (const r of resonators) {
    const dx = r.x - x, dy = r.y - y;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d < closestDist) { closestDist = d; closest = r; }
  }
  return closest;
}

// Mouse
canvas.addEventListener('mousedown', e => {
  const { x, y } = getPos(e);
  const hit = findResonator(x, y);
  if (hit) {
    dragTarget = hit;
    dragStart = { x, y };
    wasDragged = false;
  }
});

canvas.addEventListener('mousemove', e => {
  const { x, y } = getPos(e);
  hoverTarget = findResonator(x, y);
  if (dragTarget) {
    dragTarget.x = x;
    dragTarget.y = y;
    if (dragStart) {
      const dx = x - dragStart.x, dy = y - dragStart.y;
      if (dx * dx + dy * dy > 25) wasDragged = true;
    }
  }
});

canvas.addEventListener('mouseup', () => {
  dragTarget = null;
  dragStart = null;
});

canvas.addEventListener('mouseleave', () => {
  hoverTarget = null;
});

canvas.addEventListener('click', e => {
  if (wasDragged) { wasDragged = false; return; }
  const { x, y } = getPos(e);
  const hit = findResonator(x, y);
  if (!hit && resonators.length < MAX_RESONATORS) {
    createResonator(x, y);
  }
});

canvas.addEventListener('dblclick', e => {
  e.preventDefault();
  const { x, y } = getPos(e);
  const hit = findResonator(x, y);
  if (hit) removeResonator(hit);
});

// Touch
let touchTimer = null;
let touchStartedOnResonator = false;

canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const { x, y } = getPos(e);
  const hit = findResonator(x, y);

  if (hit) {
    dragTarget = hit;
    dragStart = { x, y };
    wasDragged = false;
    touchStartedOnResonator = true;
    // Long press to remove
    touchTimer = setTimeout(() => {
      if (dragTarget === hit && !wasDragged) {
        removeResonator(hit);
        dragTarget = null;
        touchStartedOnResonator = false;
      }
      touchTimer = null;
    }, 500);
  } else {
    touchStartedOnResonator = false;
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (dragTarget && e.touches.length) {
    const { x, y } = getPos(e);
    dragTarget.x = x;
    dragTarget.y = y;
    if (dragStart) {
      const dx = x - dragStart.x, dy = y - dragStart.y;
      if (dx * dx + dy * dy > 25) {
        wasDragged = true;
        if (touchTimer) { clearTimeout(touchTimer); touchTimer = null; }
      }
    }
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  if (touchTimer) { clearTimeout(touchTimer); touchTimer = null; }

  if (!touchStartedOnResonator && !wasDragged && e.changedTouches.length) {
    const { x, y } = getPos(e);
    if (resonators.length < MAX_RESONATORS) {
      createResonator(x, y);
    }
  }

  dragTarget = null;
  dragStart = null;
  wasDragged = false;
  touchStartedOnResonator = false;
}, { passive: false });

// Keyboard
document.addEventListener('keydown', e => {
  if (e.key === ' ' || e.key === 'm') {
    e.preventDefault();
    if (audioCtx) toggleMute();
  }
});

document.getElementById('soundToggle').addEventListener('click', toggleMute);

// ===================== Animation loop =====================
function animate(now) {
  const t = now / 1000;
  const dt = Math.min(t - lastTime, 0.05);
  lastTime = t;

  updateCoupling(dt);
  render(t);

  requestAnimationFrame(animate);
}

lastTime = performance.now() / 1000;
requestAnimationFrame(animate);
updateHint();
</script>
</body>
</html>
