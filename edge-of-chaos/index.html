<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Edge of Chaos</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #080810;
    overflow: hidden;
    font-family: 'Courier New', monospace;
    cursor: crosshair;
  }

  canvas { display: block; position: fixed; top: 0; left: 0; }

  #ui {
    position: fixed;
    bottom: 28px;
    left: 0;
    right: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 10;
    pointer-events: none;
    opacity: 1;
    transition: opacity 2s ease;
  }
  #ui.faded { opacity: 0.25; }

  #label {
    color: rgba(255,255,255,0.5);
    font-size: 11px;
    letter-spacing: 5px;
    text-transform: uppercase;
    margin-bottom: 10px;
    transition: color 1s ease;
  }

  #spectrum {
    display: flex;
    align-items: center;
    gap: 14px;
    color: rgba(255,255,255,0.25);
    font-size: 9px;
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  #bar-container {
    width: 180px;
    height: 1px;
    background: rgba(255,255,255,0.08);
    position: relative;
  }
  #bar-fill {
    height: 100%;
    background: rgba(255,255,255,0.35);
    width: 0%;
    transition: width 0.2s ease;
  }
  #bar-marker {
    position: absolute;
    top: -3px;
    width: 1px;
    height: 7px;
    background: rgba(255,255,255,0.5);
    left: 50%;
    pointer-events: none;
  }

  #title {
    position: fixed;
    top: 0; left: 0; right: 0;
    text-align: center;
    padding-top: 36px;
    z-index: 10;
    pointer-events: none;
    opacity: 1;
    transition: opacity 3s ease;
  }
  #title.faded { opacity: 0; }
  #title h1 {
    color: rgba(255,255,255,0.6);
    font-size: 13px;
    font-weight: 300;
    letter-spacing: 10px;
    text-transform: uppercase;
  }
  #title p {
    color: rgba(255,255,255,0.2);
    font-size: 10px;
    letter-spacing: 3px;
    margin-top: 10px;
  }

  #hint {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    color: rgba(255,255,255,0.12);
    font-size: 10px;
    letter-spacing: 4px;
    text-transform: uppercase;
    z-index: 10;
    pointer-events: none;
    opacity: 1;
    transition: opacity 2s ease;
  }
  #hint.hidden { opacity: 0; }

  #sound-toggle {
    position: fixed;
    bottom: 28px;
    right: 24px;
    z-index: 20;
    color: rgba(255,255,255,0.2);
    font-size: 10px;
    letter-spacing: 2px;
    text-transform: uppercase;
    cursor: pointer;
    padding: 6px 10px;
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 3px;
    background: rgba(8,8,16,0.5);
    transition: opacity 0.5s ease, color 0.5s ease;
    user-select: none;
  }
  #sound-toggle:hover { color: rgba(255,255,255,0.4); }
  #sound-toggle.active { color: rgba(255,255,255,0.35); border-color: rgba(255,255,255,0.15); }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div id="title">
  <h1>Edge of Chaos</h1>
  <p id="interact-hint">move your mouse</p>
</div>

<div id="hint">the boundary is where everything interesting lives</div>

<div id="ui">
  <div id="label">stillness</div>
  <div id="spectrum">
    <span>order</span>
    <div id="bar-container">
      <div id="bar-fill"></div>
      <div id="bar-marker"></div>
    </div>
    <span>chaos</span>
  </div>
</div>

<div id="sound-toggle" title="Press M to toggle">sound off</div>

<script>
// ===== Canvas setup =====
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H, particleCount;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  particleCount = Math.min(4000, Math.floor((W * H) / 500));
  ctx.fillStyle = '#080810';
  ctx.fillRect(0, 0, W, H);
  if (particles.length > 0) initParticles();
}
window.addEventListener('resize', resize);

// ===== State =====
let chaos = 0.15;
let targetChaos = 0.15;
let flowRate = 0.5;
let targetFlowRate = 0.5;
let time = 0;
let hasInteracted = false;
let interactionTime = 0;
let particles = [];
const SEED = Math.random() * 1000;

// ===== Curl noise flow field =====
// Potential function: layered sine waves. Velocity = curl of potential.
// This creates divergence-free flow (no sources/sinks).

function potential(x, y, t, c) {
  const s = 0.0025;
  // Octave 1: large, slow flow
  let p = Math.sin(x * s * 0.6 + t * 0.15 + SEED)
        * Math.cos(y * s * 0.4 + t * 0.12)
        + Math.cos((x + y) * s * 0.25 + t * 0.08) * 1.2;

  // Octave 2: medium structures — appear with some chaos
  const o2 = smoothstep(0.1, 0.4, c);
  p += o2 * (
    Math.sin(x * s * 1.8 + t * 0.25 + y * s * 0.9) * 0.7
    + Math.cos(y * s * 2.2 - t * 0.2 + x * s * 0.5 + SEED * 0.7) * 0.5
  );

  // Octave 3: fine detail — the edge zone
  const o3 = smoothstep(0.25, 0.55, c);
  p += o3 * (
    Math.sin(x * s * 4.1 + t * 0.4 + SEED * 1.3) * 0.4
    + Math.cos(y * s * 3.7 - t * 0.35 + x * s * 1.2) * 0.35
    + Math.sin((x * 0.8 - y * 1.1) * s * 3.3 + t * 0.5) * 0.25
  );

  // Octave 4: turbulent eddies — high chaos
  const o4 = smoothstep(0.5, 0.8, c);
  p += o4 * (
    Math.sin(x * s * 7.2 + t * 0.6 + SEED * 2.1) * 0.3
    + Math.cos(y * s * 8.5 - t * 0.7 + SEED * 1.7) * 0.2
    + Math.sin((x + y) * s * 6.0 + t * 0.8) * 0.2
  );

  // Noise injection — extreme chaos
  const n = smoothstep(0.7, 1.0, c);
  if (n > 0) {
    const h = Math.sin(x * 12.99 + y * 78.23 + t * 5.1) * 43758.55;
    p += n * ((h - Math.floor(h)) - 0.5) * 3.0;
  }

  return p;
}

function smoothstep(edge0, edge1, x) {
  const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
  return t * t * (3 - 2 * t);
}

// Curl: vx = dP/dy, vy = -dP/dx
const EPS = 0.8;
function fieldVelocity(x, y, t, c) {
  const vx = (potential(x, y + EPS, t, c) - potential(x, y - EPS, t, c)) / (2 * EPS);
  const vy = -(potential(x + EPS, y, t, c) - potential(x - EPS, y, t, c)) / (2 * EPS);
  return { vx, vy };
}

// ===== Color =====
// Multi-palette that shifts with chaos level

function particleColor(c, speed, age, maxAge) {
  const life = 1 - age / maxAge;
  const speedNorm = Math.min(speed / 3.5, 1);

  // Edgeness peaks at c = 0.45 (slightly left of center — the sweet spot)
  const edgeness = Math.max(0, 1 - Math.pow((c - 0.45) / 0.3, 2));

  let h, s, l;

  if (c < 0.2) {
    // Order: deep blue-violet
    h = 230 + c * 50;  // 230–240
    s = 40 + speedNorm * 25;
    l = 20 + speedNorm * 20 + life * 8;
  } else if (c < 0.4) {
    // Approaching edge: cyan-teal
    const t = (c - 0.2) / 0.2;
    h = 240 - t * 60;  // 240 → 180
    s = 50 + edgeness * 30 + speedNorm * 15;
    l = 25 + speedNorm * 25 + life * 10;
  } else if (c < 0.6) {
    // The edge: rich emerald-gold-white
    const t = (c - 0.4) / 0.2;
    h = 170 - t * 40 + speedNorm * 20; // 170 → 130, shifted by speed
    s = 55 + edgeness * 30;
    l = 30 + speedNorm * 30 + edgeness * 15 + life * 5;
  } else if (c < 0.8) {
    // Turbulence: amber-orange
    const t = (c - 0.6) / 0.2;
    h = 50 - t * 20;  // 50 → 30
    s = 60 + speedNorm * 25;
    l = 30 + speedNorm * 25;
  } else {
    // Dissolution: hot red, white flashes
    h = 15 - (c - 0.8) * 30;  // 15 → 9
    s = 65 + speedNorm * 20;
    l = 30 + speedNorm * 35;
  }

  // Alpha: brighter at the edge, fades with age
  let a = 0.15 + life * 0.35 + edgeness * 0.2 + speedNorm * 0.15;
  a = Math.min(0.85, a);

  return `hsla(${h}, ${s}%, ${l}%, ${a})`;
}

// ===== Particles =====

function createParticle(randomAge) {
  return {
    x: Math.random() * W,
    y: Math.random() * H,
    age: randomAge ? Math.random() * 800 : 0,
    maxAge: 400 + Math.random() * 800,
    prevX: 0,
    prevY: 0,
  };
}

function initParticles() {
  particles = [];
  for (let i = 0; i < particleCount; i++) {
    particles.push(createParticle(true));
  }
}

function resetParticle(p) {
  if (chaos > 0.5 && Math.random() < chaos * 0.4) {
    p.x = Math.random() * W;
    p.y = Math.random() * H;
  } else {
    const edge = Math.random() * 4 | 0;
    if (edge === 0)      { p.x = -2; p.y = Math.random() * H; }
    else if (edge === 1) { p.x = W + 2; p.y = Math.random() * H; }
    else if (edge === 2) { p.x = Math.random() * W; p.y = -2; }
    else                 { p.x = Math.random() * W; p.y = H + 2; }
  }
  p.age = 0;
  p.maxAge = 400 + Math.random() * 800;
  p.prevX = p.x;
  p.prevY = p.y;
}

// ===== Mouse =====
let mouseX = -1, mouseY = -1;

function handlePointer(x, y) {
  mouseX = x;
  mouseY = y;
  targetChaos = x / W;
  targetFlowRate = 0.3 + (1 - y / H) * 0.7;  // top = fast, bottom = slow

  if (!hasInteracted) {
    hasInteracted = true;
    document.getElementById('hint').classList.add('hidden');
    setTimeout(() => document.getElementById('title').classList.add('faded'), 4000);
  }
}

document.addEventListener('mousemove', e => handlePointer(e.clientX, e.clientY));
document.addEventListener('touchstart', e => {
  handlePointer(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: true });
document.addEventListener('touchmove', e => {
  e.preventDefault();
  handlePointer(e.touches[0].clientX, e.touches[0].clientY);
}, { passive: false });

// ===== Audio =====
let audioCtx = null;
let audioNodes = null;
let audioEnabled = false;

function initAudio() {
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  } catch (e) { return; }

  const master = audioCtx.createGain();
  master.gain.value = 0;
  master.connect(audioCtx.destination);

  // --- Oscillators: C2, G2, C3, E3 (C major chord) ---
  const freqs = [65.41, 98.00, 130.81, 164.81];
  const types = ['sine', 'sine', 'triangle', 'sine'];
  const oscs = [];
  const oscGains = [];

  for (let i = 0; i < 4; i++) {
    const osc = audioCtx.createOscillator();
    osc.type = types[i];
    osc.frequency.value = freqs[i];
    const g = audioCtx.createGain();
    g.gain.value = 0;
    osc.connect(g);
    g.connect(master);
    osc.start();
    oscs.push(osc);
    oscGains.push(g);
  }

  // --- LFO for subtle vibrato on osc1 ---
  const lfo = audioCtx.createOscillator();
  lfo.type = 'sine';
  lfo.frequency.value = 0.15;
  const lfoGain = audioCtx.createGain();
  lfoGain.gain.value = 0.5;
  lfo.connect(lfoGain);
  lfoGain.connect(oscs[0].frequency);
  lfo.start();

  // --- Noise generator ---
  const bufSize = audioCtx.sampleRate * 2;
  const noiseBuf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = noiseBuf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

  const noise = audioCtx.createBufferSource();
  noise.buffer = noiseBuf;
  noise.loop = true;

  const noiseFilter = audioCtx.createBiquadFilter();
  noiseFilter.type = 'bandpass';
  noiseFilter.frequency.value = 400;
  noiseFilter.Q.value = 2;

  const noiseGain = audioCtx.createGain();
  noiseGain.gain.value = 0;

  noise.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(master);
  noise.start();

  // --- Simple delay for spaciousness ---
  const delay = audioCtx.createDelay(1.0);
  delay.delayTime.value = 0.35;
  const delayFeedback = audioCtx.createGain();
  delayFeedback.gain.value = 0.2;
  const delayGain = audioCtx.createGain();
  delayGain.gain.value = 0;

  master.connect(delay);
  delay.connect(delayFeedback);
  delayFeedback.connect(delay);
  delay.connect(delayGain);
  delayGain.connect(audioCtx.destination);

  audioNodes = {
    master, oscs, oscGains, freqs: [...freqs],
    lfo, lfoGain, noise, noiseFilter, noiseGain,
    delay, delayFeedback, delayGain,
  };

  audioEnabled = true;
  document.getElementById('sound-toggle').textContent = 'sound on';
  document.getElementById('sound-toggle').classList.add('active');
}

function toggleAudio() {
  if (!audioCtx) {
    initAudio();
    return;
  }
  audioEnabled = !audioEnabled;
  const el = document.getElementById('sound-toggle');
  el.textContent = audioEnabled ? 'sound on' : 'sound off';
  el.classList.toggle('active', audioEnabled);
  if (!audioEnabled) {
    audioNodes.master.gain.setTargetAtTime(0, audioCtx.currentTime, 0.3);
  }
}

function updateAudio(c, fr) {
  if (!audioNodes || !audioEnabled) return;
  const t = audioCtx.currentTime;
  const sm = 0.08; // smoothing time constant

  // Master volume: gentle fade in, louder at the edge
  const edgeness = Math.max(0, 1 - Math.pow((c - 0.45) / 0.35, 2));
  const vol = 0.08 + edgeness * 0.06;
  audioNodes.master.gain.setTargetAtTime(vol, t, sm);

  // --- Oscillator levels ---
  // osc1 (C2): always present, anchoring
  audioNodes.oscGains[0].gain.setTargetAtTime(0.3 + edgeness * 0.15, t, sm);

  // osc2 (G2 / fifth): fades in at 0.15, detunes into chaos
  const g2level = smoothstep(0.1, 0.3, c);
  audioNodes.oscGains[1].gain.setTargetAtTime(g2level * 0.25, t, sm);
  // Detune: pure fifth at the edge, sharp at chaos
  const g2detune = c > 0.6 ? (c - 0.6) * 75 : 0; // up to 30 cents sharp
  audioNodes.oscs[1].frequency.setTargetAtTime(98.00 + g2detune, t, sm);

  // osc3 (C3 / octave): peaks at the edge
  const g3level = smoothstep(0.2, 0.45, c) * (1 - smoothstep(0.7, 0.95, c));
  audioNodes.oscGains[2].gain.setTargetAtTime(g3level * 0.15, t, sm);

  // osc4 (E3 / third → Eb → dissonance): character voice
  const g4level = smoothstep(0.25, 0.5, c) * 0.12;
  audioNodes.oscGains[3].gain.setTargetAtTime(g4level, t, sm);
  // E3 (164.81) at edge → Eb3 (155.56) in turbulence → detuned further in chaos
  let e3freq = 164.81;
  if (c > 0.55) e3freq = 164.81 - (c - 0.55) * 40; // drops ~18 Hz over range
  audioNodes.oscs[3].frequency.setTargetAtTime(e3freq, t, sm);

  // --- LFO: slow breathing → nervous trembling ---
  const lfoFreq = 0.12 + c * 3.5 * c; // 0.12 Hz → ~3.6 Hz quadratic
  const lfoDepth = 0.3 + c * 4;
  audioNodes.lfo.frequency.setTargetAtTime(lfoFreq, t, sm);
  audioNodes.lfoGain.gain.setTargetAtTime(lfoDepth, t, sm);

  // --- Noise: wind at edge, harsh at chaos ---
  const nLevel = smoothstep(0.15, 0.4, c) * 0.05 + smoothstep(0.6, 1.0, c) * 0.15;
  audioNodes.noiseGain.gain.setTargetAtTime(nLevel, t, sm);
  // Filter: narrow band at low chaos (singing wind), opens up at high
  const nFreq = 300 + c * 1500 + edgeness * 200;
  const nQ = Math.max(0.5, 4 - c * 5);
  audioNodes.noiseFilter.frequency.setTargetAtTime(nFreq, t, sm);
  audioNodes.noiseFilter.Q.setTargetAtTime(nQ, t, sm);

  // --- Delay: most present at the edge ---
  const delayWet = edgeness * 0.15;
  audioNodes.delayGain.gain.setTargetAtTime(delayWet, t, sm);
  audioNodes.delayFeedback.gain.setTargetAtTime(0.15 + edgeness * 0.2, t, sm);

  // Flow rate → delay time modulation (subtle)
  const delayT = 0.25 + (1 - fr) * 0.2;
  audioNodes.delay.delayTime.setTargetAtTime(delayT, t, 0.3);
}

// Sound toggle handlers
document.getElementById('sound-toggle').addEventListener('click', toggleAudio);
document.addEventListener('keydown', e => {
  if (e.key === 'm' || e.key === 'M') toggleAudio();
  if (e.key === 's' || e.key === 'S') captureScreenshot();
});

// ===== Screenshot =====
function captureScreenshot() {
  const link = document.createElement('a');
  link.download = `edge-of-chaos-${Date.now()}.png`;
  link.href = canvas.toDataURL('image/png');
  link.click();
}

// ===== UI =====
const barFill = document.getElementById('bar-fill');
const labelEl = document.getElementById('label');
const uiEl = document.getElementById('ui');

const STATES = [
  { max: 0.08, text: 'stillness',    hue: 240 },
  { max: 0.2,  text: 'equilibrium',  hue: 225 },
  { max: 0.33, text: 'structure',    hue: 200 },
  { max: 0.45, text: 'complexity',   hue: 170 },
  { max: 0.55, text: 'the edge',     hue: 140 },
  { max: 0.65, text: 'turbulence',   hue: 80 },
  { max: 0.78, text: 'instability',  hue: 45 },
  { max: 0.9,  text: 'unraveling',   hue: 20 },
  { max: 1.01, text: 'dissolution',  hue: 5 },
];

function updateUI() {
  barFill.style.width = (chaos * 100) + '%';
  for (const s of STATES) {
    if (chaos < s.max) {
      labelEl.textContent = s.text;
      labelEl.style.color = `hsla(${s.hue}, 55%, 70%, 0.6)`;
      break;
    }
  }
  if (hasInteracted && !uiEl.classList.contains('faded')) {
    uiEl.classList.add('faded');
  }
}

// ===== Main loop =====

function animate() {
  // Before interaction, gently drift to invite exploration
  if (!hasInteracted) {
    const drift = 0.12 + Math.sin(time * 0.3) * 0.08 + Math.sin(time * 0.13) * 0.05;
    targetChaos = drift;
    targetFlowRate = 0.45 + Math.sin(time * 0.2) * 0.1;
  }

  // Ease toward targets
  chaos += (targetChaos - chaos) * 0.035;
  flowRate += (targetFlowRate - flowRate) * 0.04;

  time += (0.005 + chaos * 0.01) * (0.5 + flowRate);

  // Trail fade: shorter trails at extremes, longer near the edge
  const edgeness = Math.max(0, 1 - Math.pow((chaos - 0.45) / 0.35, 2));
  const fadeAlpha = 0.02 - edgeness * 0.008 + Math.max(0, chaos - 0.7) * 0.03;
  ctx.fillStyle = `rgba(8, 8, 16, ${fadeAlpha})`;
  ctx.fillRect(0, 0, W, H);

  // Speed multiplier: base + chaos contribution
  const speedMult = (1.2 + chaos * 1.5) * (0.6 + flowRate * 0.8);

  // Batch draw - single path for thin lines, separate for thick
  ctx.lineCap = 'round';

  for (let i = 0; i < particles.length; i++) {
    const p = particles[i];

    const v = fieldVelocity(p.x, p.y, time, chaos);
    const speed = Math.sqrt(v.vx * v.vx + v.vy * v.vy) * speedMult;

    p.prevX = p.x;
    p.prevY = p.y;
    p.x += v.vx * speedMult;
    p.y += v.vy * speedMult;
    p.age++;

    // Draw
    const color = particleColor(chaos, speed, p.age, p.maxAge);
    ctx.strokeStyle = color;
    ctx.lineWidth = 0.8 + Math.min(speed / 4, 1.5);
    ctx.beginPath();
    ctx.moveTo(p.prevX, p.prevY);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();

    // Edge glow: near the sweet spot, fast particles leave bright marks
    if (edgeness > 0.3 && speed > 2.5 && Math.random() < 0.015 * edgeness) {
      const r = 1.5 + speed * 0.3;
      ctx.globalAlpha = 0.15 + edgeness * 0.15;
      ctx.fillStyle = `hsl(${150 + Math.random() * 30}, 70%, 70%)`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // High chaos sparks: occasional bright white flashes
    if (chaos > 0.7 && speed > 3 && Math.random() < 0.005 * (chaos - 0.7) * 3) {
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 1, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // Reset if dead or off screen
    if (p.age > p.maxAge || p.x < -20 || p.x > W + 20 || p.y < -20 || p.y > H + 20) {
      resetParticle(p);
    }
  }

  updateUI();
  updateAudio(chaos, flowRate);
  requestAnimationFrame(animate);
}

// ===== Vignette overlay =====
const vCanvas = document.createElement('canvas');
vCanvas.style.cssText = 'position:fixed;top:0;left:0;pointer-events:none;z-index:5;';
document.body.appendChild(vCanvas);

function drawVignette() {
  vCanvas.width = W;
  vCanvas.height = H;
  const vc = vCanvas.getContext('2d');
  const cx = W / 2, cy = H / 2;
  const r = Math.max(W, H) * 0.7;
  const grad = vc.createRadialGradient(cx, cy, r * 0.4, cx, cy, r);
  grad.addColorStop(0, 'rgba(8,8,16,0)');
  grad.addColorStop(1, 'rgba(8,8,16,0.6)');
  vc.fillStyle = grad;
  vc.fillRect(0, 0, W, H);
}

// ===== Touch detection =====
if ('ontouchstart' in window) {
  document.getElementById('interact-hint').textContent = 'touch and drag';
}

// ===== Init =====
resize();
drawVignette();
window.addEventListener('resize', drawVignette);
initParticles();
animate();
</script>
</body>
</html>
