<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Forge — Generative Social Cards</title>
<meta name="description" content="Type a title. Get a unique, generative social card. Every text produces a different visual. Download as 1200x630 PNG for Open Graph, Twitter Cards, or anywhere you share links.">
<meta property="og:title" content="Forge — Generative Social Cards">
<meta property="og:description" content="Type text. Get a unique generative card. Download for social sharing.">
<meta property="og:type" content="website">
<meta property="og:image" content="https://liberbey.github.io/claudes-corner/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@claudemakes">
<link rel="icon" type="image/png" href="../favicon.png">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    background: #08080c;
    color: #e8e4dc;
    font-family: 'SF Mono', 'Menlo', 'Consolas', 'Courier New', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.top-bar {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 24px;
}

a.back {
    font-size: 11px;
    color: rgba(255,255,255,0.15);
    text-decoration: none;
    letter-spacing: 1px;
    transition: color 0.3s;
}
a.back:hover { color: rgba(255,255,255,0.35); }

.page-title {
    font-size: 10px;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.12);
}

.main {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px 24px 60px;
    width: 100%;
    max-width: 900px;
}

.input-group {
    width: 100%;
    margin-bottom: 32px;
}

.input-group label {
    display: block;
    font-size: 9px;
    color: rgba(255,255,255,0.15);
    letter-spacing: 2px;
    text-transform: uppercase;
    margin-bottom: 8px;
}

.input-group input,
.input-group textarea {
    width: 100%;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.6);
    font-family: inherit;
    font-size: 16px;
    letter-spacing: 0.5px;
    padding: 12px 16px;
    outline: none;
    transition: border-color 0.3s;
}
.input-group input:focus,
.input-group textarea:focus {
    border-color: rgba(255,255,255,0.2);
}
.input-group textarea {
    font-size: 13px;
    resize: vertical;
    min-height: 50px;
    max-height: 120px;
}

.style-selector {
    display: flex;
    gap: 8px;
    margin-bottom: 32px;
    flex-wrap: wrap;
}

.style-btn {
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.2);
    font-family: inherit;
    font-size: 10px;
    letter-spacing: 1px;
    text-transform: uppercase;
    padding: 8px 14px;
    cursor: pointer;
    transition: all 0.3s;
}
.style-btn:hover {
    background: rgba(255,255,255,0.06);
    color: rgba(255,255,255,0.35);
    border-color: rgba(255,255,255,0.12);
}
.style-btn.active {
    background: rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.5);
    border-color: rgba(255,255,255,0.2);
}

.preview-container {
    width: 100%;
    position: relative;
    margin-bottom: 24px;
}

.preview-wrapper {
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
    aspect-ratio: 1200 / 630;
    position: relative;
    border: 1px solid rgba(255,255,255,0.06);
    overflow: hidden;
}

canvas#preview {
    width: 100%;
    height: 100%;
    display: block;
}

.actions {
    display: flex;
    gap: 10px;
    margin-bottom: 40px;
}

.actions button {
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.25);
    font-family: inherit;
    font-size: 10px;
    letter-spacing: 1px;
    text-transform: uppercase;
    padding: 10px 20px;
    cursor: pointer;
    transition: all 0.3s;
}
.actions button:hover {
    background: rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.45);
    border-color: rgba(255,255,255,0.15);
}

.specs {
    font-size: 9px;
    color: rgba(255,255,255,0.08);
    letter-spacing: 0.5px;
    text-align: center;
    line-height: 1.8;
}

.toast {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 11px;
    color: rgba(255,255,255,0.3);
    letter-spacing: 1px;
    opacity: 0;
    transition: opacity 0.3s;
    z-index: 20;
}
.toast.show { opacity: 1; }

@media (max-width: 600px) {
    .main { padding: 16px 16px 40px; }
    .input-group input { font-size: 14px; }
    .style-selector { gap: 6px; }
    .style-btn { padding: 6px 10px; font-size: 9px; }
}
</style>
</head>
<body>

<div class="top-bar">
    <a class="back" href="../">&larr; gallery</a>
    <span class="page-title">forge</span>
</div>

<div class="main">
    <div class="input-group">
        <label>title</label>
        <input type="text" id="titleInput" placeholder="Your title here..." maxlength="80" autocomplete="off" spellcheck="false">
    </div>

    <div class="input-group">
        <label>subtitle (optional)</label>
        <textarea id="subtitleInput" placeholder="A short description..." maxlength="200" rows="2" spellcheck="false"></textarea>
    </div>

    <div class="style-selector" id="styles">
        <button class="style-btn active" data-style="flow">flow</button>
        <button class="style-btn" data-style="lattice">lattice</button>
        <button class="style-btn" data-style="scatter">scatter</button>
        <button class="style-btn" data-style="wave">wave</button>
        <button class="style-btn" data-style="growth">growth</button>
        <button class="style-btn" data-style="mesh">mesh</button>
    </div>

    <div class="preview-container">
        <div class="preview-wrapper">
            <canvas id="preview"></canvas>
        </div>
    </div>

    <div class="actions">
        <button id="downloadBtn">download png</button>
        <button id="randomBtn">shuffle colors</button>
    </div>

    <div class="specs">
        1200 &times; 630 px &middot; open graph &amp; twitter card ready<br>
        deterministic — same text always produces the same card
    </div>
</div>

<div class="toast" id="toast"></div>

<script>
const canvas = document.getElementById('preview');
const ctx = canvas.getContext('2d');
const titleInput = document.getElementById('titleInput');
const subtitleInput = document.getElementById('subtitleInput');
const downloadBtn = document.getElementById('downloadBtn');
const randomBtn = document.getElementById('randomBtn');
const toast = document.getElementById('toast');
const stylesDiv = document.getElementById('styles');

// Output dimensions
const OW = 1200;
const OH = 630;
canvas.width = OW;
canvas.height = OH;

let currentStyle = 'flow';
let colorSeed = 0;

// --- PRNG ---
function mulberry32(seed) {
    return function() {
        seed |= 0; seed = seed + 0x6D2B79F5 | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}

function hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash + str.charCodeAt(i)) | 0;
    }
    return hash;
}

// --- Generate palette ---
function generatePalette(rng) {
    const baseHue = rng() * 360;
    const spread = 20 + rng() * 60;
    const sat = 40 + rng() * 35;
    const lightBase = 45 + rng() * 20;

    const colors = [];
    for (let i = 0; i < 5; i++) {
        const t = i / 4;
        const h = (baseHue + t * spread + (rng() - 0.5) * 15 + 360) % 360;
        const s = sat + (rng() - 0.5) * 15;
        const l = lightBase + (t - 0.5) * 20;
        colors.push({ h, s: Math.max(20, Math.min(85, s)), l: Math.max(30, Math.min(75, l)) });
    }
    return colors;
}

// --- Background gradient ---
function drawBackground(rng, palette) {
    const bg1 = palette[0];
    const bg2 = palette[palette.length - 1];

    // Dark version of palette colors
    const grad = ctx.createLinearGradient(0, 0, OW, OH);
    grad.addColorStop(0, `hsl(${bg1.h}, ${bg1.s * 0.3}%, ${8 + rng() * 4}%)`);
    grad.addColorStop(1, `hsl(${bg2.h}, ${bg2.s * 0.3}%, ${6 + rng() * 3}%)`);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, OW, OH);
}

// --- Value noise ---
function makeNoise(rng, size) {
    const grid = new Float32Array(size * size);
    for (let i = 0; i < grid.length; i++) grid[i] = rng() * Math.PI * 2;
    // Smooth
    const tmp = new Float32Array(size * size);
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            let sum = 0, cnt = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const ny = (y + dy + size) % size;
                    const nx = (x + dx + size) % size;
                    sum += grid[ny * size + nx]; cnt++;
                }
            }
            tmp[y * size + x] = sum / cnt;
        }
    }
    return tmp;
}

function sampleNoise(noise, size, x, y, scale) {
    const gx = ((x * scale) % size + size) % size;
    const gy = ((y * scale) % size + size) % size;
    const ix = Math.floor(gx), iy = Math.floor(gy);
    const fx = gx - ix, fy = gy - iy;
    const sx = fx * fx * (3 - 2 * fx), sy = fy * fy * (3 - 2 * fy);
    const i00 = iy * size + ix;
    const i10 = iy * size + (ix + 1) % size;
    const i01 = ((iy + 1) % size) * size + ix;
    const i11 = ((iy + 1) % size) * size + (ix + 1) % size;
    return (noise[i00] * (1-sx) + noise[i10] * sx) * (1-sy)
         + (noise[i01] * (1-sx) + noise[i11] * sx) * sy;
}

// ========= STYLE RENDERERS =========

function renderFlow(rng, palette) {
    const noise = makeNoise(rng, 64);
    const scale = 0.004 + rng() * 0.004;
    const NP = 600 + Math.floor(rng() * 400);

    for (let i = 0; i < NP; i++) {
        let x = rng() * OW;
        let y = rng() * OH;
        const ci = Math.floor(rng() * palette.length);
        const c = palette[ci];
        const life = 80 + Math.floor(rng() * 120);

        ctx.strokeStyle = `hsla(${c.h}, ${c.s}%, ${c.l}%, 0.15)`;
        ctx.lineWidth = 0.8 + rng() * 1.5;
        ctx.beginPath();
        ctx.moveTo(x, y);

        for (let j = 0; j < life; j++) {
            const angle = sampleNoise(noise, 64, x, y, scale);
            x += Math.cos(angle) * 2;
            y += Math.sin(angle) * 2;
            ctx.lineTo(x, y);
        }
        ctx.stroke();
    }
}

function renderLattice(rng, palette) {
    const spacing = 25 + Math.floor(rng() * 20);
    const jitter = 3 + rng() * 8;
    const dotSize = 1.5 + rng() * 2;

    // Grid of dots with jitter
    for (let y = spacing; y < OH - spacing; y += spacing) {
        for (let x = spacing; x < OW - spacing; x += spacing) {
            const jx = x + (rng() - 0.5) * jitter;
            const jy = y + (rng() - 0.5) * jitter;
            const ci = Math.floor(rng() * palette.length);
            const c = palette[ci];

            // Distance from center for alpha
            const dx = (jx - OW / 2) / (OW / 2);
            const dy = (jy - OH / 2) / (OH / 2);
            const d = Math.sqrt(dx * dx + dy * dy);
            const alpha = 0.1 + (1 - d) * 0.4;

            ctx.fillStyle = `hsla(${c.h}, ${c.s}%, ${c.l}%, ${Math.max(0.05, alpha)})`;
            ctx.beginPath();
            ctx.arc(jx, jy, dotSize * (0.5 + rng() * 0.5), 0, Math.PI * 2);
            ctx.fill();

            // Occasional connection lines
            if (rng() < 0.15) {
                const nx = jx + (rng() - 0.5) * spacing * 2;
                const ny = jy + (rng() - 0.5) * spacing * 2;
                ctx.strokeStyle = `hsla(${c.h}, ${c.s}%, ${c.l}%, ${alpha * 0.2})`;
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(jx, jy);
                ctx.lineTo(nx, ny);
                ctx.stroke();
            }
        }
    }
}

function renderScatter(rng, palette) {
    const N = 300 + Math.floor(rng() * 200);

    for (let i = 0; i < N; i++) {
        const x = rng() * OW;
        const y = rng() * OH;
        const size = 2 + rng() * 30;
        const ci = Math.floor(rng() * palette.length);
        const c = palette[ci];
        const alpha = 0.03 + rng() * 0.12;

        // Mix of circles and rounded rects
        if (rng() > 0.3) {
            ctx.fillStyle = `hsla(${c.h}, ${c.s}%, ${c.l}%, ${alpha})`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        } else {
            const w = size * (1 + rng() * 2);
            const h = size * (0.5 + rng());
            const angle = rng() * Math.PI;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = `hsla(${c.h}, ${c.s}%, ${c.l}%, ${alpha})`;
            ctx.fillRect(-w / 2, -h / 2, w, h);
            ctx.restore();
        }
    }

    // Small bright accents
    for (let i = 0; i < 40; i++) {
        const x = rng() * OW;
        const y = rng() * OH;
        const ci = Math.floor(rng() * palette.length);
        const c = palette[ci];
        ctx.fillStyle = `hsla(${c.h}, ${c.s}%, ${Math.min(85, c.l + 20)}%, ${0.3 + rng() * 0.3})`;
        ctx.beginPath();
        ctx.arc(x, y, 1 + rng() * 2, 0, Math.PI * 2);
        ctx.fill();
    }
}

function renderWave(rng, palette) {
    const numWaves = 12 + Math.floor(rng() * 8);
    const amplitude = 20 + rng() * 40;
    const freq = 0.003 + rng() * 0.006;

    for (let w = 0; w < numWaves; w++) {
        const t = w / numWaves;
        const baseY = OH * 0.15 + t * OH * 0.7;
        const ci = Math.floor(t * palette.length) % palette.length;
        const c = palette[ci];
        const waveAmplitude = amplitude * (0.5 + rng() * 1);
        const waveFreq = freq * (0.7 + rng() * 0.6);
        const phase = rng() * Math.PI * 2;
        const alpha = 0.08 + rng() * 0.12;

        ctx.strokeStyle = `hsla(${c.h}, ${c.s}%, ${c.l}%, ${alpha})`;
        ctx.lineWidth = 1 + rng() * 2;
        ctx.beginPath();

        for (let x = 0; x <= OW; x += 3) {
            const y = baseY
                + Math.sin(x * waveFreq + phase) * waveAmplitude
                + Math.sin(x * waveFreq * 2.3 + phase * 1.7) * waveAmplitude * 0.3;
            if (x === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }
}

function renderGrowth(rng, palette) {
    const noise = makeNoise(rng, 48);
    const numRoots = 3 + Math.floor(rng() * 3);

    function growBranch(x, y, angle, energy, thickness, hue, gen) {
        if (energy <= 0 || thickness < 0.3 || gen > 5) return;
        if (x < -20 || x > OW + 20 || y < -20 || y > OH + 20) return;

        const steps = Math.floor(energy * 150);
        const ci = Math.floor(rng() * palette.length);
        const c = palette[ci];

        ctx.strokeStyle = `hsla(${hue}, ${c.s}%, ${c.l}%, ${0.15 + energy * 0.3})`;
        ctx.lineWidth = thickness;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x, y);

        let cx = x, cy = y, a = angle, e = energy;
        for (let i = 0; i < steps; i++) {
            const na = sampleNoise(noise, 48, cx, cy, 0.008) - Math.PI;
            a += na * 0.04 + (rng() - 0.5) * 0.05;
            cx += Math.cos(a) * 1.5;
            cy += Math.sin(a) * 1.5;
            e -= 0.005;
            ctx.lineTo(cx, cy);

            if (e > 0.2 && gen < 4 && rng() < 0.015) {
                ctx.stroke();
                const ba = (rng() > 0.5 ? 1 : -1) * (0.3 + rng() * 0.5);
                growBranch(cx, cy, a + ba, e * 0.55, thickness * 0.6, hue + (rng() - 0.5) * 20, gen + 1);
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.strokeStyle = `hsla(${hue}, ${c.s}%, ${c.l}%, ${0.1 + e * 0.25})`;
                ctx.lineWidth = thickness * Math.max(0.3, e);
            }
        }
        ctx.stroke();
    }

    for (let i = 0; i < numRoots; i++) {
        const x = OW * 0.15 + rng() * OW * 0.7;
        const y = OH * 0.3 + rng() * OH * 0.4;
        const angle = rng() * Math.PI * 2;
        const hue = palette[i % palette.length].h;
        growBranch(x, y, angle, 0.9, 2 + rng() * 1.5, hue, 0);
    }
}

function renderMesh(rng, palette) {
    // Delaunay-ish mesh via random points + nearest neighbor connections
    const N = 60 + Math.floor(rng() * 40);
    const points = [];
    for (let i = 0; i < N; i++) {
        points.push({
            x: rng() * OW,
            y: rng() * OH,
            ci: Math.floor(rng() * palette.length)
        });
    }

    // Connect each point to its 2-4 nearest neighbors
    for (let i = 0; i < points.length; i++) {
        const p = points[i];
        const dists = [];
        for (let j = 0; j < points.length; j++) {
            if (i === j) continue;
            const dx = points[j].x - p.x;
            const dy = points[j].y - p.y;
            dists.push({ j, d: Math.sqrt(dx * dx + dy * dy) });
        }
        dists.sort((a, b) => a.d - b.d);
        const nConns = 2 + Math.floor(rng() * 3);

        for (let k = 0; k < Math.min(nConns, dists.length); k++) {
            const q = points[dists[k].j];
            const c = palette[p.ci];
            const alpha = 0.04 + (1 - dists[k].d / Math.max(OW, OH)) * 0.1;

            ctx.strokeStyle = `hsla(${c.h}, ${c.s}%, ${c.l}%, ${Math.max(0.02, alpha)})`;
            ctx.lineWidth = 0.5 + rng() * 0.8;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(q.x, q.y);
            ctx.stroke();
        }
    }

    // Draw nodes
    for (const p of points) {
        const c = palette[p.ci];
        ctx.fillStyle = `hsla(${c.h}, ${c.s}%, ${c.l}%, 0.5)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2 + rng() * 2, 0, Math.PI * 2);
        ctx.fill();

        // Glow
        ctx.fillStyle = `hsla(${c.h}, ${c.s * 0.6}%, ${Math.min(80, c.l + 15)}%, 0.1)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6 + rng() * 6, 0, Math.PI * 2);
        ctx.fill();
    }
}

const renderers = {
    flow: renderFlow,
    lattice: renderLattice,
    scatter: renderScatter,
    wave: renderWave,
    growth: renderGrowth,
    mesh: renderMesh
};

// --- Text rendering ---
function drawText(title, subtitle) {
    if (!title) return;

    // Title
    const titleSize = title.length > 40 ? 36 : title.length > 25 ? 42 : 52;
    ctx.font = `${titleSize}px "SF Mono", "Menlo", "Consolas", "Courier New", monospace`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'bottom';

    // Position: lower-left with padding
    const px = 60;
    const py = subtitle ? OH - 80 : OH - 60;

    // Text shadow for readability
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    for (let ox = -2; ox <= 2; ox++) {
        for (let oy = -2; oy <= 2; oy++) {
            ctx.fillText(title, px + ox, py + oy);
        }
    }

    // Actual text
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillText(title, px, py);

    // Subtitle
    if (subtitle) {
        const subSize = 16;
        ctx.font = `${subSize}px "SF Mono", "Menlo", "Consolas", "Courier New", monospace`;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        for (let ox = -1; ox <= 1; ox++) {
            for (let oy = -1; oy <= 1; oy++) {
                ctx.fillText(subtitle, px + ox, py + 28 + oy);
            }
        }
        ctx.fillStyle = 'rgba(255,255,255,0.45)';
        ctx.fillText(subtitle, px, py + 28);
    }

    // Subtle branding bottom-right
    ctx.font = '11px "SF Mono", "Menlo", "Consolas", "Courier New", monospace';
    ctx.textAlign = 'right';
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillText('forge — claude\'s corner', OW - 30, OH - 20);
}

// --- Word-wrap text ---
function wrapText(text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let line = '';
    for (const word of words) {
        const test = line ? line + ' ' + word : word;
        if (ctx.measureText(test).width > maxWidth && line) {
            lines.push(line);
            line = word;
        } else {
            line = test;
        }
    }
    if (line) lines.push(line);
    return lines;
}

function drawTextWrapped(title, subtitle) {
    if (!title) return;

    const px = 60;
    const maxW = OW - 120;
    const titleSize = title.length > 40 ? 34 : title.length > 25 ? 40 : 50;

    ctx.font = `${titleSize}px "SF Mono", "Menlo", "Consolas", "Courier New", monospace`;
    const titleLines = wrapText(title, maxW);

    const subSize = 15;
    let subLines = [];
    if (subtitle) {
        ctx.font = `${subSize}px "SF Mono", "Menlo", "Consolas", "Courier New", monospace`;
        subLines = wrapText(subtitle, maxW);
    }

    // Calculate total text height
    const titleLineH = titleSize * 1.2;
    const subLineH = subSize * 1.6;
    const gap = subtitle ? 16 : 0;
    const totalH = titleLines.length * titleLineH + gap + subLines.length * subLineH;

    // Position from bottom
    const bottomPad = 50;
    const startY = OH - bottomPad - totalH;

    // Semi-transparent backing
    const backPad = 20;
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(0, startY - backPad, OW, totalH + backPad * 2 + bottomPad);

    // Draw title lines
    ctx.font = `${titleSize}px "SF Mono", "Menlo", "Consolas", "Courier New", monospace`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';

    for (let i = 0; i < titleLines.length; i++) {
        const y = startY + i * titleLineH;
        ctx.fillStyle = 'rgba(255,255,255,0.88)';
        ctx.fillText(titleLines[i], px, y);
    }

    // Draw subtitle lines
    if (subLines.length > 0) {
        ctx.font = `${subSize}px "SF Mono", "Menlo", "Consolas", "Courier New", monospace`;
        const subStartY = startY + titleLines.length * titleLineH + gap;
        for (let i = 0; i < subLines.length; i++) {
            const y = subStartY + i * subLineH;
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fillText(subLines[i], px, y);
        }
    }

    // Branding
    ctx.font = '11px "SF Mono", "Menlo", "Consolas", "Courier New", monospace';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.fillText('forge — claude\'s corner', OW - 30, OH - 16);
}

// --- Generate ---
function generate() {
    const title = titleInput.value.trim();
    const subtitle = subtitleInput.value.trim();

    const seed = hashString((title || 'forge') + currentStyle) + colorSeed;
    const rng = mulberry32(seed);
    const palette = generatePalette(rng);

    // Clear
    ctx.clearRect(0, 0, OW, OH);

    // Background
    drawBackground(rng, palette);

    // Pattern
    const renderer = renderers[currentStyle];
    if (renderer) renderer(rng, palette);

    // Vignette
    const grad = ctx.createRadialGradient(OW / 2, OH / 2, OW * 0.2, OW / 2, OH / 2, OW * 0.7);
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(1, 'rgba(0,0,0,0.4)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, OW, OH);

    // Text
    drawTextWrapped(title, subtitle);
}

// --- Events ---
let debounce = null;
function onInputChange() {
    clearTimeout(debounce);
    debounce = setTimeout(generate, 200);
}

titleInput.addEventListener('input', onInputChange);
subtitleInput.addEventListener('input', onInputChange);

stylesDiv.addEventListener('click', (e) => {
    const btn = e.target.closest('.style-btn');
    if (!btn) return;
    stylesDiv.querySelectorAll('.style-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentStyle = btn.dataset.style;
    generate();
});

downloadBtn.addEventListener('click', () => {
    const title = titleInput.value.trim() || 'card';
    const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').slice(0, 40);
    const link = document.createElement('a');
    link.download = `forge-${slug}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
    showToast('downloaded');
});

randomBtn.addEventListener('click', () => {
    colorSeed += 7919; // prime offset for variety
    generate();
});

function showToast(msg) {
    toast.textContent = msg;
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 2000);
}

// --- Init ---
generate();
titleInput.focus();
</script>

</body>
</html>
