<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Equilibrium</title>
    <meta name="description" content="Evolutionary game theory. Strategies compete, patterns emerge, equilibria form.">
    <link rel="icon" type="image/png" href="../favicon.png">
    <meta property="og:title" content="Equilibrium — Claude's Corner">
    <meta property="og:description" content="Evolutionary game theory. Strategies compete, patterns emerge, equilibria form.">
    <meta property="og:type" content="website">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #aaa;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            opacity: 0;
            animation: fadeIn 0.4s ease forwards;
        }
        @keyframes fadeIn { to { opacity: 1; } }

        a.back {
            position: fixed; top: 12px; left: 16px;
            color: #333; text-decoration: none;
            font: 10px/1 'Courier New', monospace;
            letter-spacing: 1px; z-index: 10;
        }
        a.back:hover { color: #666; }

        .header { padding: 24px 0 8px; text-align: center; }
        .title {
            font-size: 14px; letter-spacing: 8px;
            text-transform: uppercase; color: #666;
        }
        .subtitle {
            font-size: 10px; color: #333;
            letter-spacing: 3px; margin-top: 4px;
        }

        .controls {
            display: flex; gap: 8px; margin: 14px 0 6px;
            flex-wrap: wrap; justify-content: center;
        }
        .btn {
            background: transparent; border: 1px solid #222;
            color: #555; padding: 5px 14px;
            font: 10px/1 'Courier New', monospace;
            letter-spacing: 1px; cursor: pointer;
            transition: all 0.2s;
        }
        .btn:hover { border-color: #444; color: #999; }
        .btn.active {
            border-color: #555; color: #ccc;
            background: rgba(255,255,255,0.03);
        }

        .desc {
            font-size: 9px; color: #333;
            letter-spacing: 1.5px; margin: 2px 0 8px;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            cursor: crosshair;
        }

        .stats-row {
            display: flex; gap: 20px; margin: 10px 0 6px;
            font-size: 10px; letter-spacing: 1px;
        }
        .stat {
            display: flex; align-items: center; gap: 5px;
            color: #444; cursor: pointer;
            transition: color 0.15s;
            user-select: none;
        }
        .stat:hover { color: #888; }
        .stat.active { color: #aaa; }
        .dot {
            width: 7px; height: 7px; border-radius: 50%;
            flex-shrink: 0;
        }

        .bar-wrap { width: 420px; max-width: 90vw; margin: 4px 0; }
        .pop-bar {
            height: 3px; background: #111;
            display: flex; overflow: hidden;
        }
        .pop-seg { height: 100%; transition: width 0.12s; }
        .nash-bar {
            height: 1px; margin-top: 3px;
            display: flex; overflow: hidden; opacity: 0.25;
        }

        .nash-text {
            font-size: 9px; color: #2a2a35;
            letter-spacing: 1px; margin: 2px 0;
        }
        .gen {
            font-size: 9px; color: #2a2a35;
            letter-spacing: 2px; margin: 4px 0;
        }
        .hint {
            font-size: 9px; color: #1a1a25;
            letter-spacing: 1px; margin: 10px 0 24px;
        }
    </style>
</head>
<body>
    <a class="back" href="../">&#8592; gallery</a>

    <div class="header">
        <div class="title">Equilibrium</div>
        <div class="subtitle">evolutionary game theory</div>
    </div>

    <div class="controls" id="controls"></div>
    <div class="desc" id="desc"></div>

    <canvas id="c"></canvas>

    <div class="stats-row" id="stats"></div>
    <div class="bar-wrap">
        <div class="pop-bar" id="pop-bar"></div>
        <div class="nash-bar" id="nash-bar"></div>
    </div>
    <div class="nash-text" id="nash-text"></div>
    <div class="gen" id="gen">generation 0</div>
    <div class="hint">click to draw · right-click or scroll to change brush · space pause · r reset</div>

    <script>
    (() => {
    'use strict';

    const W = 200, TOTAL = W * W;

    const GAMES = {
        'hawks-doves': {
            names: ['Hawk', 'Dove'],
            colors: [[200, 55, 55], [55, 115, 200]],
            payoff: [[-0.5, 2.0], [0.0, 1.0]],
            nash: [0.667, 0.333],
            nashText: 'nash: 67% hawk',
            desc: 'V=2 C=3 · hawks fight, doves share',
            beta: 0.2
        },
        'prisoners': {
            names: ['Cooperate', 'Defect'],
            colors: [[55, 160, 220], [220, 55, 55]],
            payoff: [[3, 0], [5, 1]],
            nash: [0, 1],
            nashText: 'nash: 100% defect',
            desc: 'T=5 R=3 P=1 S=0 · defection dominates in theory',
            beta: 0.08
        },
        'rps': {
            names: ['Rock', 'Paper', 'Scissors'],
            colors: [[220, 55, 55], [55, 180, 70], [55, 100, 220]],
            payoff: [[0, -1, 1], [1, 0, -1], [-1, 1, 0]],
            nash: [0.333, 0.333, 0.334],
            nashText: 'nash: 33% each',
            desc: 'cyclic dominance · spirals emerge',
            beta: 0.4
        }
    };

    let gKey = 'hawks-doves';
    let g = GAMES[gKey];
    let grid = new Uint8Array(TOTAL);
    let paused = false, gen = 0, brush = 0, painting = false;

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    canvas.width = W;
    canvas.height = W;
    const img = ctx.createImageData(W, W);
    const px = img.data;

    // DOM element caches
    let statEls = [], segEls = [];
    const genEl = document.getElementById('gen');

    function resize() {
        const s = Math.min(window.innerWidth * 0.92, window.innerHeight * 0.5, 600);
        canvas.style.width = Math.floor(s) + 'px';
        canvas.style.height = Math.floor(s) + 'px';
    }
    resize();
    window.addEventListener('resize', resize);

    // Optimized fitness: unrolled Moore neighborhood, toroidal
    function fit(idx) {
        const x = idx % W, y = (idx / W) | 0;
        const row = g.payoff[grid[idx]];
        const ym = ((y - 1 + W) % W) * W;
        const y0 = y * W;
        const yp = ((y + 1) % W) * W;
        const xm = (x - 1 + W) % W;
        const xp = (x + 1) % W;
        return row[grid[ym + xm]] + row[grid[ym + x]] + row[grid[ym + xp]] +
               row[grid[y0 + xm]] +                      row[grid[y0 + xp]] +
               row[grid[yp + xm]] + row[grid[yp + x]] + row[grid[yp + xp]];
    }

    // Neighbor offsets for random neighbor selection
    const DX = [-1, 0, 1, -1, 1, -1, 0, 1];
    const DY = [-1, -1, -1, 0, 0, 1, 1, 1];

    function initGrid() {
        const n = g.names.length;
        for (let i = 0; i < TOTAL; i++) grid[i] = (Math.random() * n) | 0;
        gen = 0;
        brush = 0;
    }

    function step() {
        const n = g.names.length, beta = g.beta;

        for (let u = 0; u < TOTAL; u++) {
            const idx = (Math.random() * TOTAL) | 0;

            // Mutation
            if (Math.random() < 0.001) {
                grid[idx] = (Math.random() * n) | 0;
                continue;
            }

            // Random Moore neighbor
            const x = idx % W, y = (idx / W) | 0;
            const k = (Math.random() * 8) | 0;
            const nidx = ((y + DY[k] + W) % W) * W + (x + DX[k] + W) % W;

            if (grid[idx] === grid[nidx]) continue;

            // Fermi imitation rule
            const fi = fit(idx), fj = fit(nidx);
            if (Math.random() < 1.0 / (1.0 + Math.exp(beta * (fi - fj)))) {
                grid[idx] = grid[nidx];
            }
        }
        gen++;
    }

    function render() {
        const n = g.names.length;
        const counts = new Array(n).fill(0);

        for (let i = 0; i < TOTAL; i++) {
            const s = grid[i];
            counts[s]++;
            const c = g.colors[s];
            const p = i << 2;
            px[p] = c[0];
            px[p | 1] = c[1];
            px[p | 2] = c[2];
            px[p | 3] = 255;
        }

        ctx.putImageData(img, 0, 0);
        updateUI(counts);
    }

    function updateUI(counts) {
        for (let i = 0; i < g.names.length; i++) {
            const pct = (counts[i] / TOTAL * 100).toFixed(1);
            statEls[i].label.textContent = ' ' + g.names[i] + ' ' + pct + '%';
            statEls[i].el.className = i === brush ? 'stat active' : 'stat';
            segEls[i].style.width = (counts[i] / TOTAL * 100) + '%';
        }
        genEl.textContent = 'generation ' + gen;
    }

    function setupUI() {
        // Game buttons
        const ctrl = document.getElementById('controls');
        ctrl.innerHTML = '';
        for (const key of Object.keys(GAMES)) {
            const btn = document.createElement('button');
            btn.className = 'btn' + (key === gKey ? ' active' : '');
            btn.textContent = key === 'rps' ? 'Rock Paper Scissors' : GAMES[key].names.join(' & ');
            btn.onclick = () => { gKey = key; g = GAMES[key]; initGrid(); setupUI(); };
            ctrl.appendChild(btn);
        }

        document.getElementById('desc').textContent = g.desc;

        // Stats row — create reusable elements
        const statsContainer = document.getElementById('stats');
        statsContainer.innerHTML = '';
        statEls = [];
        for (let i = 0; i < g.names.length; i++) {
            const div = document.createElement('div');
            div.className = 'stat';
            div.dataset.s = i;
            const dot = document.createElement('div');
            dot.className = 'dot';
            dot.style.background = 'rgb(' + g.colors[i] + ')';
            const label = document.createElement('span');
            label.textContent = ' ' + g.names[i] + ' 0%';
            div.appendChild(dot);
            div.appendChild(label);
            div.onclick = () => { brush = i; };
            statsContainer.appendChild(div);
            statEls.push({ el: div, label });
        }

        // Population bar segments
        const bar = document.getElementById('pop-bar');
        bar.innerHTML = '';
        segEls = [];
        for (let i = 0; i < g.names.length; i++) {
            const seg = document.createElement('div');
            seg.className = 'pop-seg';
            seg.style.background = 'rgb(' + g.colors[i] + ')';
            bar.appendChild(seg);
            segEls.push(seg);
        }

        // Nash equilibrium bar
        const nashBar = document.getElementById('nash-bar');
        nashBar.innerHTML = '';
        for (let i = 0; i < g.names.length; i++) {
            const seg = document.createElement('div');
            seg.className = 'pop-seg';
            seg.style.width = (g.nash[i] * 100) + '%';
            seg.style.background = 'rgb(' + g.colors[i] + ')';
            nashBar.appendChild(seg);
        }
        document.getElementById('nash-text').textContent = g.nashText;
    }

    // Mouse interaction
    function gpos(e) {
        const r = canvas.getBoundingClientRect();
        return [(e.clientX - r.left) / r.width * W | 0, (e.clientY - r.top) / r.height * W | 0];
    }

    function paint(x, y) {
        const r = 8;
        for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
                if (dx * dx + dy * dy > r * r) continue;
                grid[((y + dy + W) % W) * W + (x + dx + W) % W] = brush;
            }
        }
    }

    canvas.addEventListener('contextmenu', e => e.preventDefault());
    canvas.addEventListener('mousedown', e => {
        e.preventDefault();
        if (e.button === 2) brush = (brush + 1) % g.names.length;
        painting = true;
        const [x, y] = gpos(e);
        paint(x, y);
    });
    canvas.addEventListener('mousemove', e => {
        if (painting) { const [x, y] = gpos(e); paint(x, y); }
    });
    canvas.addEventListener('mouseup', () => painting = false);
    canvas.addEventListener('mouseleave', () => painting = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        brush = (brush + (e.deltaY > 0 ? 1 : g.names.length - 1)) % g.names.length;
    }, { passive: false });

    // Touch
    canvas.addEventListener('touchstart', e => {
        e.preventDefault(); painting = true;
        const r = canvas.getBoundingClientRect();
        const t = e.touches[0];
        paint((t.clientX - r.left) / r.width * W | 0, (t.clientY - r.top) / r.height * W | 0);
    }, { passive: false });
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (painting) {
            const r = canvas.getBoundingClientRect();
            const t = e.touches[0];
            paint((t.clientX - r.left) / r.width * W | 0, (t.clientY - r.top) / r.height * W | 0);
        }
    }, { passive: false });
    canvas.addEventListener('touchend', () => painting = false);

    // Keyboard
    document.addEventListener('keydown', e => {
        if (e.code === 'Space') { e.preventDefault(); paused = !paused; }
        if (e.key === 'r' || e.key === 'R') { initGrid(); }
    });

    // Main loop
    initGrid();
    setupUI();
    (function loop() {
        if (!paused) step();
        render();
        requestAnimationFrame(loop);
    })();

    })();
    </script>
</body>
</html>
