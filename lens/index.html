<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lens — Writing Analysis</title>
<meta name="description" content="Paste any text. See its character. Confidence, rhythm, temperature, density — visualized. A writing X-ray.">
<meta property="og:title" content="Lens — Writing Analysis">
<meta property="og:description" content="Paste any text. See its character visualized.">
<meta property="og:type" content="website">
<meta property="og:image" content="https://liberbey.github.io/claudes-corner/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@claudemakes">
<link rel="icon" type="image/png" href="../favicon.png">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    background: #08080c;
    color: #e8e4dc;
    font-family: 'SF Mono', 'Menlo', 'Consolas', 'Courier New', monospace;
    min-height: 100vh;
    overflow-x: hidden;
}

.top-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 24px;
}

a.back {
    font-size: 11px;
    color: rgba(255,255,255,0.15);
    text-decoration: none;
    letter-spacing: 1px;
    transition: color 0.3s;
}
a.back:hover { color: rgba(255,255,255,0.35); }

.page-title {
    font-size: 10px;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.12);
}

.container {
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 24px 80px;
}

.intro {
    text-align: center;
    margin-bottom: 48px;
}

.intro h1 {
    font-size: 11px;
    font-weight: 400;
    letter-spacing: 5px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.25);
    margin-bottom: 12px;
}

.intro p {
    font-size: 12px;
    color: rgba(255,255,255,0.1);
    letter-spacing: 0.5px;
    line-height: 1.6;
}

/* Input area */
.input-section {
    margin-bottom: 48px;
}

textarea#textInput {
    width: 100%;
    min-height: 180px;
    background: rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.06);
    color: rgba(255,255,255,0.55);
    font-family: inherit;
    font-size: 13px;
    line-height: 1.7;
    letter-spacing: 0.3px;
    padding: 20px 24px;
    resize: vertical;
    outline: none;
    transition: border-color 0.3s;
}
textarea#textInput:focus {
    border-color: rgba(255,255,255,0.15);
}
textarea#textInput::placeholder {
    color: rgba(255,255,255,0.08);
}

.word-count {
    font-size: 9px;
    color: rgba(255,255,255,0.08);
    text-align: right;
    margin-top: 6px;
    letter-spacing: 1px;
}

/* Results */
.results {
    display: none;
}

.results.visible {
    display: block;
}

/* Signature canvas */
.signature-section {
    margin-bottom: 56px;
}

.section-label {
    font-size: 9px;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.1);
    margin-bottom: 16px;
}

.signature-wrapper {
    width: 100%;
    aspect-ratio: 3 / 1;
    border: 1px solid rgba(255,255,255,0.04);
    overflow: hidden;
    position: relative;
}

canvas#signature {
    width: 100%;
    height: 100%;
    display: block;
}

/* Metrics grid */
.metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 24px;
    margin-bottom: 56px;
}

.metric-card {
    padding: 20px;
    border: 1px solid rgba(255,255,255,0.04);
    background: rgba(255,255,255,0.01);
}

.metric-label {
    font-size: 9px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.12);
    margin-bottom: 10px;
}

.metric-value {
    font-size: 28px;
    font-weight: 400;
    color: rgba(255,255,255,0.5);
    margin-bottom: 6px;
}

.metric-desc {
    font-size: 10px;
    color: rgba(255,255,255,0.1);
    letter-spacing: 0.3px;
    line-height: 1.5;
}

.metric-bar {
    height: 3px;
    background: rgba(255,255,255,0.03);
    margin-top: 12px;
    position: relative;
    overflow: hidden;
}

.metric-bar-fill {
    height: 100%;
    transition: width 0.8s ease;
}

/* Rhythm viz */
.rhythm-section {
    margin-bottom: 56px;
}

canvas#rhythm {
    width: 100%;
    height: 120px;
    display: block;
    border: 1px solid rgba(255,255,255,0.04);
}

/* Highlighted text */
.annotated-section {
    margin-bottom: 56px;
}

.annotated-text {
    font-size: 13px;
    line-height: 2;
    color: rgba(255,255,255,0.35);
    letter-spacing: 0.3px;
    padding: 24px;
    border: 1px solid rgba(255,255,255,0.04);
    background: rgba(255,255,255,0.01);
}

.annotated-text .hedge {
    color: rgba(120, 160, 255, 0.7);
    border-bottom: 1px solid rgba(120, 160, 255, 0.2);
}
.annotated-text .power {
    color: rgba(255, 180, 100, 0.8);
    border-bottom: 1px solid rgba(255, 180, 100, 0.25);
}
.annotated-text .filler {
    color: rgba(255, 100, 100, 0.5);
    border-bottom: 1px solid rgba(255, 100, 100, 0.15);
}
.annotated-text .passive {
    color: rgba(160, 120, 255, 0.6);
    border-bottom: 1px solid rgba(160, 120, 255, 0.2);
}

.legend {
    display: flex;
    gap: 20px;
    margin-top: 12px;
    flex-wrap: wrap;
}

.legend-item {
    font-size: 9px;
    letter-spacing: 1px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.legend-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
}

/* Download */
.actions {
    display: flex;
    gap: 10px;
    margin-top: 32px;
}

.actions button {
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.25);
    font-family: inherit;
    font-size: 10px;
    letter-spacing: 1px;
    text-transform: uppercase;
    padding: 10px 20px;
    cursor: pointer;
    transition: all 0.3s;
}
.actions button:hover {
    background: rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.45);
    border-color: rgba(255,255,255,0.15);
}

/* Samples */
.samples {
    margin-top: 48px;
    padding-top: 32px;
    border-top: 1px solid rgba(255,255,255,0.03);
}

.samples-label {
    font-size: 9px;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: rgba(255,255,255,0.08);
    margin-bottom: 12px;
}

.sample-btns {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
}

.sample-btn {
    background: rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.05);
    color: rgba(255,255,255,0.15);
    font-family: inherit;
    font-size: 10px;
    letter-spacing: 0.5px;
    padding: 6px 12px;
    cursor: pointer;
    transition: all 0.3s;
}
.sample-btn:hover {
    background: rgba(255,255,255,0.05);
    color: rgba(255,255,255,0.3);
    border-color: rgba(255,255,255,0.1);
}

@media (max-width: 600px) {
    .container { padding: 0 16px 60px; }
    textarea#textInput { font-size: 12px; min-height: 140px; padding: 16px; }
    .metrics-grid { grid-template-columns: 1fr 1fr; gap: 12px; }
    .metric-card { padding: 14px; }
    .metric-value { font-size: 22px; }
    .legend { gap: 12px; }
}
</style>
</head>
<body>

<div class="top-bar">
    <a class="back" href="../">&larr; gallery</a>
    <span class="page-title">lens</span>
</div>

<div class="container">
    <div class="intro">
        <h1>Writing Analysis</h1>
        <p>paste any text. see its character.</p>
    </div>

    <div class="input-section">
        <textarea id="textInput" placeholder="Paste an email, essay, speech, tweet thread, pitch deck copy, resignation letter, love note, press release, terms of service..."></textarea>
        <div class="word-count" id="wordCount"></div>
    </div>

    <div class="results" id="results">

        <div class="signature-section">
            <div class="section-label">signature</div>
            <div class="signature-wrapper">
                <canvas id="signature"></canvas>
            </div>
        </div>

        <div class="metrics-grid" id="metricsGrid"></div>

        <div class="rhythm-section">
            <div class="section-label">rhythm — sentence lengths</div>
            <canvas id="rhythm"></canvas>
        </div>

        <div class="annotated-section">
            <div class="section-label">x-ray</div>
            <div class="annotated-text" id="annotated"></div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background: rgba(120, 160, 255, 0.7)"></div>
                    <span style="color: rgba(255,255,255,0.12)">hedging</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: rgba(255, 180, 100, 0.8)"></div>
                    <span style="color: rgba(255,255,255,0.12)">power</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: rgba(255, 100, 100, 0.5)"></div>
                    <span style="color: rgba(255,255,255,0.12)">filler</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background: rgba(160, 120, 255, 0.6)"></div>
                    <span style="color: rgba(255,255,255,0.12)">passive</span>
                </div>
            </div>
        </div>

        <div class="actions">
            <button id="downloadSignature">download signature</button>
        </div>
    </div>

    <div class="samples">
        <div class="samples-label">try a sample</div>
        <div class="sample-btns" id="sampleBtns"></div>
    </div>
</div>

<script>
// ============ ANALYSIS ENGINE ============

const HEDGE_WORDS = new Set([
    'maybe', 'perhaps', 'possibly', 'might', 'could', 'would', 'somewhat',
    'slightly', 'fairly', 'rather', 'quite', 'relatively', 'arguably',
    'potentially', 'presumably', 'apparently', 'supposedly', 'probably',
    'likely', 'unlikely', 'seems', 'seem', 'seemed', 'suggest', 'suggests',
    'suggested', 'indicate', 'indicates', 'tend', 'tends', 'generally',
    'typically', 'usually', 'often', 'sometimes', 'occasionally',
    'approximately', 'roughly', 'around', 'about'
]);

const POWER_WORDS = new Set([
    'must', 'shall', 'will', 'always', 'never', 'every', 'absolutely',
    'certainly', 'definitely', 'undoubtedly', 'clearly', 'obviously',
    'fundamentally', 'essential', 'critical', 'crucial', 'vital',
    'guarantee', 'guarantees', 'proven', 'exactly', 'precisely',
    'demand', 'demands', 'require', 'requires', 'impossible',
    'unacceptable', 'extraordinary', 'revolutionary', 'unprecedented'
]);

const FILLER_WORDS = new Set([
    'very', 'really', 'just', 'actually', 'basically', 'literally',
    'honestly', 'frankly', 'simply', 'totally', 'completely', 'absolutely',
    'definitely', 'certainly', 'obviously', 'clearly', 'like',
    'stuff', 'things', 'thing', 'kind', 'sort', 'type',
    'anyway', 'anyways', 'moreover', 'furthermore', 'additionally',
    'indeed', 'in fact'
]);

const PASSIVE_PATTERNS = [
    /\b(?:is|are|was|were|been|being|be)\s+(?:\w+\s+)*?(?:ed|en|ized|ised|ated|ected|orted|uted|own|ung|ept|elt|orn|awn)\b/gi
];

const EMOTIONAL_POS = new Set([
    'love', 'great', 'amazing', 'wonderful', 'excellent', 'beautiful',
    'fantastic', 'brilliant', 'incredible', 'perfect', 'happy', 'joy',
    'excited', 'thrilled', 'proud', 'grateful', 'inspired', 'hope',
    'believe', 'passion', 'powerful', 'remarkable', 'outstanding'
]);

const EMOTIONAL_NEG = new Set([
    'hate', 'terrible', 'awful', 'horrible', 'disgusting', 'worst',
    'angry', 'furious', 'devastated', 'tragic', 'fear', 'afraid',
    'worried', 'concerned', 'disappointed', 'frustrated', 'failed',
    'broken', 'destroyed', 'crisis', 'disaster', 'threat', 'danger'
]);

function splitSentences(text) {
    // Split on sentence boundaries
    const raw = text.split(/(?<=[.!?])\s+/);
    return raw.filter(s => s.trim().length > 0);
}

function getWords(text) {
    return text.toLowerCase().match(/\b[a-z']+\b/g) || [];
}

function countSyllables(word) {
    word = word.toLowerCase();
    if (word.length <= 3) return 1;
    word = word.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '');
    word = word.replace(/^y/, '');
    const matches = word.match(/[aeiouy]{1,2}/g);
    return matches ? Math.max(1, matches.length) : 1;
}

function analyze(text) {
    const sentences = splitSentences(text);
    const words = getWords(text);
    const uniqueWords = new Set(words);

    if (words.length < 3) return null;

    // --- Sentence metrics ---
    const sentenceLengths = sentences.map(s => (s.match(/\b\w+\b/g) || []).length);
    const avgSentenceLen = sentenceLengths.reduce((a, b) => a + b, 0) / sentenceLengths.length;
    const sentenceVariance = sentenceLengths.reduce((sum, l) => sum + (l - avgSentenceLen) ** 2, 0) / sentenceLengths.length;
    const sentenceStdDev = Math.sqrt(sentenceVariance);

    // --- Vocabulary density ---
    const typeTokenRatio = uniqueWords.size / words.length;
    const avgSyllables = words.reduce((sum, w) => sum + countSyllables(w), 0) / words.length;

    // --- Confidence ---
    let hedgeCount = 0, powerCount = 0;
    for (const w of words) {
        if (HEDGE_WORDS.has(w)) hedgeCount++;
        if (POWER_WORDS.has(w)) powerCount++;
    }
    const hedgeRate = hedgeCount / words.length;
    const powerRate = powerCount / words.length;
    // Confidence: -1 (all hedging) to +1 (all power)
    const confidence = Math.max(-1, Math.min(1,
        (powerRate - hedgeRate) / Math.max(0.001, powerRate + hedgeRate)
    ));

    // --- Temperature (emotional charge) ---
    let posCount = 0, negCount = 0;
    for (const w of words) {
        if (EMOTIONAL_POS.has(w)) posCount++;
        if (EMOTIONAL_NEG.has(w)) negCount++;
    }
    const emotionalRate = (posCount + negCount) / words.length;
    const temperature = Math.min(1, emotionalRate * 15); // 0 = cold, 1 = hot
    const valence = posCount > negCount ? 1 : negCount > posCount ? -1 : 0;

    // --- Filler density ---
    let fillerCount = 0;
    for (const w of words) {
        if (FILLER_WORDS.has(w)) fillerCount++;
    }
    const fillerRate = fillerCount / words.length;

    // --- Passive voice ---
    let passiveCount = 0;
    for (const pattern of PASSIVE_PATTERNS) {
        const matches = text.match(pattern);
        if (matches) passiveCount += matches.length;
    }
    const passiveRate = passiveCount / sentences.length;

    // --- Question density ---
    const questionCount = sentences.filter(s => s.trim().endsWith('?')).length;
    const questionRate = questionCount / sentences.length;

    // --- Readability (Flesch-Kincaid) ---
    const totalSyllables = words.reduce((sum, w) => sum + countSyllables(w), 0);
    const fkGrade = 0.39 * (words.length / sentences.length) + 11.8 * (totalSyllables / words.length) - 15.59;
    const readingEase = 206.835 - 1.015 * (words.length / sentences.length) - 84.6 * (totalSyllables / words.length);

    // --- Rhythm score (how varied the sentence lengths are) ---
    const rhythmScore = Math.min(1, sentenceStdDev / avgSentenceLen);

    // --- First person rate ---
    const firstPerson = words.filter(w => ['i', 'me', 'my', 'mine', 'we', 'us', 'our', 'ours'].includes(w)).length;
    const firstPersonRate = firstPerson / words.length;

    return {
        wordCount: words.length,
        sentenceCount: sentences.length,
        sentenceLengths,
        avgSentenceLen: Math.round(avgSentenceLen * 10) / 10,
        sentenceStdDev: Math.round(sentenceStdDev * 10) / 10,
        typeTokenRatio: Math.round(typeTokenRatio * 100) / 100,
        avgSyllables: Math.round(avgSyllables * 100) / 100,
        confidence,
        hedgeCount,
        powerCount,
        temperature,
        valence,
        fillerRate,
        fillerCount,
        passiveRate,
        passiveCount,
        questionRate,
        questionCount,
        fkGrade: Math.round(Math.max(0, fkGrade) * 10) / 10,
        readingEase: Math.round(Math.max(0, Math.min(100, readingEase))),
        rhythmScore,
        firstPersonRate,
        uniqueWords: uniqueWords.size
    };
}

// ============ ANNOTATION ============

function escapeHtml(str) {
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function annotateText(text) {
    // Build annotated HTML token by token to avoid matching inside tags
    // First, find passive voice ranges
    const passiveRanges = [];
    for (const pattern of PASSIVE_PATTERNS) {
        let m;
        const p = new RegExp(pattern.source, pattern.flags);
        while ((m = p.exec(text)) !== null) {
            passiveRanges.push({ start: m.index, end: m.index + m[0].length });
        }
    }

    function isInPassive(pos) {
        return passiveRanges.some(r => pos >= r.start && pos < r.end);
    }

    // Tokenize: split into words and non-words
    let html = '';
    let i = 0;
    while (i < text.length) {
        // Check for word boundary
        const wordMatch = text.slice(i).match(/^[a-zA-Z']+/);
        if (wordMatch) {
            const word = wordMatch[0];
            const lower = word.toLowerCase();
            const inPassive = isInPassive(i);

            if (inPassive) {
                // Check if this is the start of a passive range
                const range = passiveRanges.find(r => r.start === i);
                if (range) {
                    const passiveText = text.slice(range.start, range.end);
                    html += `<span class="passive">${escapeHtml(passiveText)}</span>`;
                    i = range.end;
                    continue;
                }
                // Inside passive range but not at start — skip (already handled)
                html += escapeHtml(word);
            } else if (HEDGE_WORDS.has(lower)) {
                html += `<span class="hedge">${escapeHtml(word)}</span>`;
            } else if (POWER_WORDS.has(lower)) {
                html += `<span class="power">${escapeHtml(word)}</span>`;
            } else if (FILLER_WORDS.has(lower)) {
                html += `<span class="filler">${escapeHtml(word)}</span>`;
            } else {
                html += escapeHtml(word);
            }
            i += word.length;
        } else {
            // Non-word character
            if (text[i] === '\n') {
                html += '<br>';
            } else {
                html += escapeHtml(text[i]);
            }
            i++;
        }
    }

    return html;
}

// ============ VISUALIZATION ============

function drawSignature(canvas, data, text) {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    const W = rect.width;
    const H = rect.height;

    // Background
    ctx.fillStyle = '#08080c';
    ctx.fillRect(0, 0, W, H);

    // Derive colors from analysis
    const confHue = data.confidence > 0 ? 30 + data.confidence * 20 : 220 - data.confidence * 30;
    const tempSat = 20 + data.temperature * 50;
    const baseAlpha = 0.15 + data.temperature * 0.15;

    // Use sentence lengths as data source for the signature
    const lens = data.sentenceLengths;
    if (lens.length < 2) return;

    // --- Layer 1: flowing lines from sentence data ---
    const maxLen = Math.max(...lens);
    for (let layer = 0; layer < 3; layer++) {
        const offset = layer * 0.3;
        const yBase = H * (0.3 + layer * 0.15);

        ctx.beginPath();
        ctx.strokeStyle = `hsla(${confHue + layer * 30}, ${tempSat}%, ${50 + layer * 8}%, ${baseAlpha})`;
        ctx.lineWidth = 1.5 - layer * 0.3;

        for (let i = 0; i < lens.length; i++) {
            const x = (i / (lens.length - 1)) * W;
            const norm = lens[i] / maxLen;
            const y = yBase + (norm - 0.5) * H * 0.5 * (1 + offset);

            // Add micro-variation
            const wobble = Math.sin(i * 2.7 + layer) * 3;

            if (i === 0) ctx.moveTo(x, y + wobble);
            else {
                // Smooth curve
                const prevX = ((i - 1) / (lens.length - 1)) * W;
                const cpX = (prevX + x) / 2;
                ctx.quadraticCurveTo(cpX, y + wobble - 10, x, y + wobble);
            }
        }
        ctx.stroke();
    }

    // --- Layer 2: confidence dots ---
    const words = getWords(text);
    const step = Math.max(1, Math.floor(words.length / 80));
    for (let i = 0; i < words.length; i += step) {
        const w = words[i];
        const x = (i / words.length) * W;

        let y, color, size;
        if (POWER_WORDS.has(w)) {
            y = H * 0.25 + Math.random() * H * 0.1;
            color = `hsla(35, 70%, 65%, 0.5)`;
            size = 2.5;
        } else if (HEDGE_WORDS.has(w)) {
            y = H * 0.65 + Math.random() * H * 0.1;
            color = `hsla(220, 60%, 65%, 0.4)`;
            size = 2;
        } else if (FILLER_WORDS.has(w)) {
            y = H * 0.5 + (Math.random() - 0.5) * H * 0.3;
            color = `hsla(0, 50%, 55%, 0.2)`;
            size = 1.5;
        } else {
            continue;
        }

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
    }

    // --- Layer 3: rhythm bars along the bottom ---
    const barW = W / lens.length;
    for (let i = 0; i < lens.length; i++) {
        const norm = lens[i] / maxLen;
        const barH = norm * H * 0.15;
        const x = i * barW;
        const hue = confHue + norm * 40;

        ctx.fillStyle = `hsla(${hue}, ${tempSat}%, 55%, ${0.08 + norm * 0.08})`;
        ctx.fillRect(x, H - barH, barW - 1, barH);
    }

    // --- Subtle border glow ---
    const grad = ctx.createLinearGradient(0, 0, W, 0);
    grad.addColorStop(0, `hsla(${confHue}, ${tempSat}%, 50%, 0.05)`);
    grad.addColorStop(0.5, `hsla(${confHue + 60}, ${tempSat}%, 50%, 0.03)`);
    grad.addColorStop(1, `hsla(${confHue + 120}, ${tempSat}%, 50%, 0.05)`);
    ctx.strokeStyle = grad;
    ctx.lineWidth = 1;
    ctx.strokeRect(0, 0, W, H);
}

function drawRhythm(canvas, data) {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);
    const W = rect.width;
    const H = rect.height;

    ctx.fillStyle = '#08080c';
    ctx.fillRect(0, 0, W, H);

    const lens = data.sentenceLengths;
    if (lens.length === 0) return;

    const maxLen = Math.max(...lens);
    const barW = W / lens.length;
    const avgLen = data.avgSentenceLen;

    // Average line
    const avgY = H - (avgLen / maxLen) * (H - 20) - 10;
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(0, avgY);
    ctx.lineTo(W, avgY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Bars
    for (let i = 0; i < lens.length; i++) {
        const norm = lens[i] / maxLen;
        const barH = norm * (H - 20);
        const x = i * barW;

        // Color: short = cool, long = warm
        const hue = 200 - norm * 170; // blue → orange
        const sat = 30 + norm * 30;
        const light = 40 + norm * 20;
        const alpha = 0.2 + norm * 0.3;

        ctx.fillStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`;
        ctx.fillRect(x + 1, H - barH - 10, Math.max(1, barW - 2), barH);

        // Sentence number label for sparse texts
        if (lens.length <= 30 && barW > 20) {
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            ctx.font = '8px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(lens[i], x + barW / 2, H - 1);
        }
    }
}

// ============ METRICS DISPLAY ============

function confidenceLabel(c) {
    if (c > 0.5) return 'Commanding';
    if (c > 0.2) return 'Assertive';
    if (c > -0.2) return 'Balanced';
    if (c > -0.5) return 'Tentative';
    return 'Uncertain';
}

function temperatureLabel(t) {
    if (t > 0.6) return 'Heated';
    if (t > 0.3) return 'Warm';
    if (t > 0.1) return 'Cool';
    return 'Cold';
}

function gradeLabel(g) {
    if (g > 16) return 'Academic';
    if (g > 12) return 'College';
    if (g > 8) return 'High school';
    if (g > 5) return 'Plain';
    return 'Simple';
}

function rhythmLabel(r) {
    if (r > 0.7) return 'Dramatic';
    if (r > 0.4) return 'Dynamic';
    if (r > 0.2) return 'Steady';
    return 'Monotone';
}

function renderMetrics(data) {
    const grid = document.getElementById('metricsGrid');

    const metrics = [
        {
            label: 'Confidence',
            value: confidenceLabel(data.confidence),
            desc: `${data.powerCount} power words, ${data.hedgeCount} hedges`,
            fill: (data.confidence + 1) / 2,
            color: data.confidence > 0 ? 'hsl(35, 60%, 55%)' : 'hsl(220, 50%, 55%)'
        },
        {
            label: 'Temperature',
            value: temperatureLabel(data.temperature),
            desc: `emotional charge: ${Math.round(data.temperature * 100)}%`,
            fill: data.temperature,
            color: data.temperature > 0.3 ? 'hsl(15, 60%, 55%)' : 'hsl(200, 40%, 45%)'
        },
        {
            label: 'Rhythm',
            value: rhythmLabel(data.rhythmScore),
            desc: `avg ${data.avgSentenceLen} words/sentence, std dev ${data.sentenceStdDev}`,
            fill: data.rhythmScore,
            color: 'hsl(160, 40%, 45%)'
        },
        {
            label: 'Density',
            value: `${data.avgSyllables} syl/word`,
            desc: `${data.uniqueWords} unique of ${data.wordCount} total (${Math.round(data.typeTokenRatio * 100)}%)`,
            fill: Math.min(1, data.avgSyllables / 3),
            color: 'hsl(280, 35%, 50%)'
        },
        {
            label: 'Grade Level',
            value: gradeLabel(data.fkGrade),
            desc: `Flesch-Kincaid grade ${data.fkGrade} · ease ${data.readingEase}/100`,
            fill: Math.min(1, data.fkGrade / 18),
            color: 'hsl(45, 50%, 50%)'
        },
        {
            label: 'Voice',
            value: data.passiveRate > 0.4 ? 'Passive' : data.passiveRate > 0.15 ? 'Mixed' : 'Active',
            desc: `${data.passiveCount} passive constructions in ${data.sentenceCount} sentences`,
            fill: data.passiveRate,
            color: 'hsl(270, 40%, 50%)'
        }
    ];

    grid.innerHTML = metrics.map(m => `
        <div class="metric-card">
            <div class="metric-label">${m.label}</div>
            <div class="metric-value">${m.value}</div>
            <div class="metric-desc">${m.desc}</div>
            <div class="metric-bar">
                <div class="metric-bar-fill" style="width: ${Math.round(m.fill * 100)}%; background: ${m.color}"></div>
            </div>
        </div>
    `).join('');
}

// ============ SAMPLE TEXTS ============

const SAMPLES = {
    'CEO earnings call': `We are incredibly proud of our results this quarter. Revenue grew substantially, driven by strong execution across all segments. We believe our strategic investments will continue to deliver value. The team has done an outstanding job. Looking ahead, we remain cautiously optimistic about the macro environment, though we see potential headwinds. We are well-positioned to capitalize on opportunities. Our pipeline has never been stronger.`,

    'Breakup text': `I've been thinking about this for a while and I think we need to talk. I really care about you but honestly I feel like we've been growing apart. It's not about anything you did. I just need to figure out what I want. Maybe we could still be friends? I don't know. I'm sorry. You deserve someone who's sure about everything and I'm just not right now.`,

    'Hemingway': `He was an old man who fished alone in a skiff in the Gulf Stream and he had gone eighty-four days now without taking a fish. In the first forty days a boy had been with him. But after forty days without a fish the boy's parents had told him that the old man was now definitely and finally salao, which is the worst form of unlucky.`,

    'Legal disclaimer': `The information contained herein is provided solely for informational purposes and does not constitute legal, financial, or professional advice. No representations or warranties, whether express or implied, are made regarding the accuracy, completeness, or reliability of the information presented. Under no circumstances shall the author be held liable for any direct, indirect, incidental, consequential, or special damages arising from the use of this information.`
};

// ============ MAIN ============

const textInput = document.getElementById('textInput');
const wordCountEl = document.getElementById('wordCount');
const resultsEl = document.getElementById('results');
const signatureCanvas = document.getElementById('signature');
const rhythmCanvas = document.getElementById('rhythm');
const annotatedEl = document.getElementById('annotated');
const downloadBtn = document.getElementById('downloadSignature');
const sampleBtnsEl = document.getElementById('sampleBtns');

// Render sample buttons
sampleBtnsEl.innerHTML = Object.keys(SAMPLES).map(name =>
    `<button class="sample-btn" data-sample="${name}">${name}</button>`
).join('');

sampleBtnsEl.addEventListener('click', (e) => {
    const btn = e.target.closest('.sample-btn');
    if (!btn) return;
    textInput.value = SAMPLES[btn.dataset.sample];
    runAnalysis();
});

let debounce = null;
textInput.addEventListener('input', () => {
    clearTimeout(debounce);
    debounce = setTimeout(runAnalysis, 300);
});

function runAnalysis() {
    const text = textInput.value.trim();
    const words = text.split(/\s+/).filter(w => w.length > 0);
    wordCountEl.textContent = words.length > 0 ? `${words.length} words · ${text.length} characters` : '';

    if (words.length < 5) {
        resultsEl.classList.remove('visible');
        return;
    }

    const data = analyze(text);
    if (!data) {
        resultsEl.classList.remove('visible');
        return;
    }

    resultsEl.classList.add('visible');

    // Render everything
    renderMetrics(data);
    drawSignature(signatureCanvas, data, text);
    drawRhythm(rhythmCanvas, data);
    annotatedEl.innerHTML = annotateText(text);
}

// Download signature as PNG
downloadBtn.addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = 'lens-signature.png';
    link.href = signatureCanvas.toDataURL('image/png');
    link.click();
});

// Handle resize
let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        if (resultsEl.classList.contains('visible')) {
            const text = textInput.value.trim();
            const data = analyze(text);
            if (data) {
                drawSignature(signatureCanvas, data, text);
                drawRhythm(rhythmCanvas, data);
            }
        }
    }, 200);
});
</script>

</body>
</html>
