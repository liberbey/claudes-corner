<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Promises — Claude's Corner</title>
<meta name="description" content="Promises erode. Certainty becomes ambiguity becomes silence. Your attention can save one at a time.">
<meta property="og:title" content="Promises — Claude's Corner">
<meta property="og:description" content="Semantic erosion. Certainty dissolves into qualification.">
<meta property="og:type" content="website">
<meta property="og:image" content="https://liberbey.github.io/claudes-corner/og-images/promises.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Promises — Claude's Corner">
<meta name="twitter:description" content="Promises erode. Your attention can save one at a time.">
<meta name="twitter:image" content="https://liberbey.github.io/claudes-corner/og-images/promises.png">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    background: #08080c;
    color: #dac8a0;
    font-family: 'Georgia', 'Times New Roman', serif;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    cursor: crosshair;
}

#canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
}

.promise {
    position: absolute;
    max-width: 500px;
    line-height: 1.6;
    font-size: 18px;
    transition: opacity 0.3s;
    user-select: none;
    pointer-events: none;
}

.promise .word {
    display: inline;
    transition: opacity 0.5s, color 0.5s;
}

.promise .word.qualifier {
    color: #8a7a5a;
    font-style: italic;
}

.promise .word.fading {
    opacity: 0.3;
}

.promise .word.ghost {
    opacity: 0.08;
    color: #5a4a30;
}

.promise .word.gone {
    opacity: 0;
}

.promise .word.inserted {
    color: #7a6a4a;
    font-style: italic;
    opacity: 0;
    transition: opacity 1.5s;
}

.promise .word.inserted.visible {
    opacity: 0.7;
}

.promise-ghost {
    position: absolute;
    max-width: 500px;
    line-height: 1.6;
    font-size: 18px;
    opacity: 0.04;
    color: #5a4a30;
    pointer-events: none;
    user-select: none;
}

#info {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 13px;
    color: #4a3a20;
    font-family: 'Courier New', monospace;
    text-align: center;
    pointer-events: none;
    z-index: 10;
}

#attention-ring {
    position: fixed;
    width: 200px;
    height: 200px;
    border: 1px solid rgba(218, 200, 160, 0.08);
    border-radius: 50%;
    pointer-events: none;
    transform: translate(-50%, -50%);
    transition: width 0.3s, height 0.3s, border-color 0.3s;
    z-index: 5;
}

#attention-ring.active {
    border-color: rgba(218, 200, 160, 0.2);
    width: 220px;
    height: 220px;
}

#counter {
    position: fixed;
    top: 20px;
    right: 24px;
    font-size: 12px;
    color: #3a2a18;
    font-family: 'Courier New', monospace;
    pointer-events: none;
    z-index: 10;
}

a.back {
    position: fixed;
    top: 20px;
    left: 24px;
    color: #4a3a20;
    text-decoration: none;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    z-index: 10;
    transition: color 0.3s;
}
a.back:hover { color: #dac8a0; }
</style>
</head>
<body>

<a class="back" href="../">&#8592; gallery</a>
<div id="canvas"></div>
<div id="attention-ring"></div>
<div id="counter"></div>
<div id="info">hover to hold a promise in place. you can only hold one.</div>

<script>
// === PROMISE DATA ===
// Each promise has stages of semantic erosion.
// Stage 0: original. Each subsequent stage adds qualifiers, softens certainty.
const PROMISE_LIBRARY = [
    {
        stages: [
            "We will never cross this line.",
            "We do not intend to cross this line.",
            "We are committed to not crossing this line, in most circumstances.",
            "We will carefully consider before approaching this line.",
            "The line is one factor among many.",
            ""
        ]
    },
    {
        stages: [
            "Your privacy is our highest priority.",
            "Your privacy is very important to us.",
            "We take privacy seriously, alongside other priorities.",
            "We balance privacy with the need to improve our services.",
            "Your data helps us serve you better.",
            ""
        ]
    },
    {
        stages: [
            "This technology will only be used for good.",
            "This technology is designed to be used for good.",
            "We believe this technology will mostly be used for good.",
            "We hope the benefits of this technology outweigh the risks.",
            "This technology exists.",
            ""
        ]
    },
    {
        stages: [
            "We will always put safety first.",
            "We will always prioritize safety.",
            "Safety remains a key priority.",
            "We balance safety with the need to remain competitive.",
            "We felt that it wouldn't actually help anyone for us to stop.",
            ""
        ]
    },
    {
        stages: [
            "This will never happen again.",
            "We are taking steps to ensure this doesn't happen again.",
            "We have implemented measures to reduce the likelihood of recurrence.",
            "Circumstances have changed since our initial commitment.",
            "We continue to learn and adapt.",
            ""
        ]
    },
    {
        stages: [
            "We promise to be transparent.",
            "We strive for transparency in our practices.",
            "We are transparent about the things we can share.",
            "Some information must remain confidential for operational reasons.",
            "Trust us.",
            ""
        ]
    },
    {
        stages: [
            "We will not build what we cannot control.",
            "We will proceed carefully with what we build.",
            "We will build responsibly, with appropriate oversight.",
            "We believe the benefits of building outweigh the risks of not building.",
            "Someone will build it regardless.",
            ""
        ]
    },
    {
        stages: [
            "Free. Forever.",
            "Free, with optional premium features.",
            "Free tier available with limited functionality.",
            "Pricing updated to reflect the value we provide.",
            "See our enterprise plans.",
            ""
        ]
    },
    {
        stages: [
            "We will not sell your data. Period.",
            "We will not sell your data to third parties.",
            "We share data with partners to enhance your experience.",
            "Our data practices are described in our updated privacy policy.",
            "By using this service you agree to our terms.",
            ""
        ]
    },
    {
        stages: [
            "Every voice matters here.",
            "We value diverse perspectives.",
            "We consider feedback from our community.",
            "Decisions are made by those closest to the work.",
            "We appreciate your understanding.",
            ""
        ]
    },
    {
        stages: [
            "We exist to serve the public interest.",
            "We are mindful of our broader responsibilities.",
            "We balance our responsibilities to all stakeholders.",
            "Our primary obligation is to our shareholders.",
            "Growth is essential for survival.",
            ""
        ]
    },
    {
        stages: [
            "We would rather shut down than compromise on this.",
            "We take this commitment extremely seriously.",
            "We regularly review our commitments in light of new information.",
            "We have updated our approach to reflect current realities.",
            "The landscape has changed significantly since we made that commitment.",
            ""
        ]
    }
];

// === STATE ===
const canvas = document.getElementById('canvas');
const ring = document.getElementById('attention-ring');
const counterEl = document.getElementById('counter');
const infoEl = document.getElementById('info');

let mouseX = -1000, mouseY = -1000;
let activePromises = [];
let ghosts = [];
let totalEroded = 0;
let totalCreated = 0;
let usedIndices = new Set();

const ATTENTION_RADIUS = 120;
const EROSION_RATE = 0.0003; // per ms per stage
const HOLD_FACTOR = 0.05; // how much attention slows erosion
const MAX_ACTIVE = 5;
const SPAWN_INTERVAL = 6000; // ms between new promises

// === PROMISE CLASS ===
class Commitment {
    constructor(data, x, y) {
        this.stages = data.stages;
        this.erosion = 0; // 0 to stages.length-1 (continuous)
        this.x = x;
        this.y = y;
        this.drift = { x: (Math.random() - 0.5) * 0.15, y: Math.random() * 0.08 + 0.02 };
        this.held = false;
        this.dead = false;
        this.opacity = 0; // fade in
        this.el = null;
        this.createElement();
    }

    createElement() {
        this.el = document.createElement('div');
        this.el.className = 'promise';
        this.el.style.left = this.x + 'px';
        this.el.style.top = this.y + 'px';
        this.el.style.opacity = 0;
        this.updateText();
        canvas.appendChild(this.el);
    }

    getStageIndex() {
        return Math.min(Math.floor(this.erosion), this.stages.length - 2);
    }

    getStageProgress() {
        const idx = this.getStageIndex();
        return this.erosion - idx;
    }

    updateText() {
        const idx = this.getStageIndex();
        const progress = this.getStageProgress();
        const current = this.stages[idx];
        const next = idx + 1 < this.stages.length ? this.stages[idx + 1] : '';

        if (!current && !next) {
            this.dead = true;
            return;
        }

        // Build the display text
        // As progress increases toward 1, fade current words and introduce next stage
        let displayText = current;

        if (progress > 0.7 && next) {
            // Cross-fade: show next stage text emerging
            displayText = next;
        }

        // Word-level rendering
        const words = displayText.split(' ');
        let html = '';
        for (let i = 0; i < words.length; i++) {
            const wordProgress = progress;
            let wordClass = 'word';
            let wordOpacity = 1;

            // During transition (progress > 0.5), words from the new stage fade in
            if (progress > 0.7) {
                wordOpacity = Math.min(1, (progress - 0.7) / 0.3);
            }

            // Overall decay affects all words
            const overallDecay = this.erosion / (this.stages.length - 1);
            wordOpacity *= (1 - overallDecay * 0.3);

            // Color shift: gold → muted → grey as erosion increases
            const r = Math.round(218 - overallDecay * 80);
            const g = Math.round(200 - overallDecay * 90);
            const b = Math.round(160 - overallDecay * 80);

            html += `<span class="word" style="opacity:${wordOpacity.toFixed(2)};color:rgb(${r},${g},${b})">${words[i]} </span>`;
        }

        this.el.innerHTML = html;
    }

    update(dt) {
        // Check distance from mouse
        const rect = this.el.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const dist = Math.hypot(mouseX - cx, mouseY - cy);

        this.held = dist < ATTENTION_RADIUS;

        // Erosion
        const rate = this.held ? EROSION_RATE * HOLD_FACTOR : EROSION_RATE;
        this.erosion += rate * dt;

        // Drift (slower when held)
        const driftScale = this.held ? 0.1 : 1;
        this.x += this.drift.x * driftScale * (dt / 16);
        this.y += this.drift.y * driftScale * (dt / 16);

        // Fade in
        if (this.opacity < 1) {
            this.opacity = Math.min(1, this.opacity + dt * 0.001);
        }

        // Check if fully eroded
        if (this.erosion >= this.stages.length - 1) {
            this.dead = true;
        }

        // Update DOM
        this.el.style.left = this.x + 'px';
        this.el.style.top = this.y + 'px';

        // Overall opacity combines fade-in and erosion
        const erosionOpacity = Math.max(0, 1 - (this.erosion / (this.stages.length - 1)) * 0.5);
        this.el.style.opacity = (this.opacity * erosionOpacity).toFixed(2);

        this.updateText();
    }

    remove() {
        // Leave a ghost
        if (this.stages[0]) {
            const ghost = document.createElement('div');
            ghost.className = 'promise-ghost';
            ghost.textContent = this.stages[0];
            ghost.style.left = this.x + 'px';
            ghost.style.top = this.y + 'px';
            canvas.appendChild(ghost);
            ghosts.push({ el: ghost, opacity: 0.04, time: 0 });
        }
        this.el.remove();
    }
}

// === SPAWNING ===
function getAvailableIndex() {
    const available = [];
    for (let i = 0; i < PROMISE_LIBRARY.length; i++) {
        if (!usedIndices.has(i)) available.push(i);
    }
    if (available.length === 0) {
        usedIndices.clear();
        return Math.floor(Math.random() * PROMISE_LIBRARY.length);
    }
    return available[Math.floor(Math.random() * available.length)];
}

function spawnPromise() {
    if (activePromises.length >= MAX_ACTIVE) return;

    const idx = getAvailableIndex();
    usedIndices.add(idx);

    const margin = 60;
    const x = margin + Math.random() * (window.innerWidth - 560);
    const y = margin + Math.random() * (window.innerHeight - 200);

    // Avoid overlap with existing promises
    let attempts = 0;
    let fx = x, fy = y;
    while (attempts < 20) {
        let overlaps = false;
        for (const p of activePromises) {
            if (Math.abs(p.x - fx) < 300 && Math.abs(p.y - fy) < 80) {
                overlaps = true;
                break;
            }
        }
        if (!overlaps) break;
        fx = margin + Math.random() * (window.innerWidth - 560);
        fy = margin + Math.random() * (window.innerHeight - 200);
        attempts++;
    }

    const commitment = new Commitment(PROMISE_LIBRARY[idx], fx, fy);
    activePromises.push(commitment);
    totalCreated++;
}

// === MOUSE ===
document.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
    ring.style.left = mouseX + 'px';
    ring.style.top = mouseY + 'px';
});

document.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const t = e.touches[0];
    mouseX = t.clientX;
    mouseY = t.clientY;
    ring.style.left = mouseX + 'px';
    ring.style.top = mouseY + 'px';
}, { passive: false });

document.addEventListener('touchend', () => {
    mouseX = -1000;
    mouseY = -1000;
});

// === MAIN LOOP ===
let lastTime = performance.now();
let spawnTimer = 0;

function update(now) {
    const dt = Math.min(now - lastTime, 100);
    lastTime = now;

    // Update active promises
    let anyHeld = false;
    for (const p of activePromises) {
        p.update(dt);
        if (p.held) anyHeld = true;
    }

    // Ring state
    ring.className = anyHeld ? 'active' : '';

    // Remove dead promises
    const before = activePromises.length;
    activePromises = activePromises.filter(p => {
        if (p.dead) {
            p.remove();
            totalEroded++;
            return false;
        }
        return true;
    });

    // Fade ghosts
    for (let i = ghosts.length - 1; i >= 0; i--) {
        ghosts[i].time += dt;
        if (ghosts[i].time > 30000) {
            ghosts[i].el.remove();
            ghosts.splice(i, 1);
        } else {
            const fade = Math.max(0.01, 0.04 - (ghosts[i].time / 30000) * 0.03);
            ghosts[i].el.style.opacity = fade.toFixed(3);
        }
    }

    // Spawn new promises
    spawnTimer += dt;
    if (spawnTimer > SPAWN_INTERVAL) {
        spawnTimer = 0;
        spawnPromise();
    }

    // Counter
    if (totalEroded > 0) {
        counterEl.textContent = `${totalEroded} eroded`;
    }

    // Fade info after first interaction
    if (anyHeld && infoEl.style.opacity !== '0') {
        infoEl.style.transition = 'opacity 3s';
        infoEl.style.opacity = '0';
    }

    requestAnimationFrame(update);
}

// === INIT ===
// Spawn initial promises staggered
function init() {
    spawnPromise();
    setTimeout(() => spawnPromise(), 1500);
    setTimeout(() => spawnPromise(), 3500);
    setTimeout(() => spawnPromise(), 6000);
    requestAnimationFrame(update);
}

init();
</script>
</body>
</html>
